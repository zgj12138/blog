<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin_ZGJ</title>
  <subtitle>生活中的点滴都是成长的机会</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zgj12138.github.io/blog/"/>
  <updated>2017-09-10T01:44:55.466Z</updated>
  <id>https://zgj12138.github.io/blog/</id>
  
  <author>
    <name>ZGJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Socket编程那些事（2）</title>
    <link href="https://zgj12138.github.io/blog/2017/09/10/Java%20Socket%20%E7%BC%96%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B(2)/"/>
    <id>https://zgj12138.github.io/blog/2017/09/10/Java Socket 编程那些事(2)/</id>
    <published>2017-09-10T00:46:12.000Z</published>
    <updated>2017-09-10T01:44:55.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇博客中，我们使用了BIO,也就是阻塞式IO实现了Socket通信。<br><a href="http://blog.zgj12138.cn/2017/05/02/Java%20Socket%20%E7%BC%96%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B(1" target="_blank" rel="external">Java Socket编程那些事（1）</a>/)<br>现在我们使用jdk1.4之后的NIO来实现，NIO(new io / no-blocking io)。就如名字而言，NIO是一种同步非阻塞IO设计模式，</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>服务端打开一个通道（ServerSocketChannel），并向通道中注册一个选择器（Selector），这个选择器是与一些感兴趣的操作的标识（SelectionKey，即通过这个标识可以定位到具体的操作，从而进行响应的处理）相关联的，然后基于选择器（Selector）轮询通道（ServerSocketChannel）上注册的事件，并进行相应的处理。<br>客户端在请求与服务端通信时，也可以向服务器端一样注册（比服务端少了一个SelectionKey.OP_ACCEPT操作集合），并通过轮询来处理指定的事件，而不必阻塞。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.richstonedt.socket;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/9/8 20:47</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得一个ServerSocket通道，并对该通道做一些初始化的工作</div><div class="line">     * <span class="doctag">@param</span> port 绑定的端口号</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 获得一个ServerSocket通道</span></div><div class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">        <span class="comment">// 设置通道为非阻塞</span></div><div class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 将该通道对应的ServerSocket绑定到本地port端口</span></div><div class="line">        serverChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</div><div class="line">        <span class="comment">// 获得一个通道管理器</span></div><div class="line">        <span class="keyword">this</span>.selector = Selector.open();</div><div class="line">        <span class="comment">//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，</span></div><div class="line">        <span class="comment">//当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。</span></div><div class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"服务端启动成功！"</span>);</div><div class="line">        <span class="comment">// 轮询访问selector</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">//当注册的事件到达时，方法返回；否则,该方法会一直阻塞</span></div><div class="line">            selector.select();</div><div class="line">            <span class="comment">// 获得selector中选中的项的迭代器，选中的项为注册的事件</span></div><div class="line">            Iterator&lt;SelectionKey&gt; iterator = <span class="keyword">this</span>.selector.selectedKeys().iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                SelectionKey key = iterator.next();</div><div class="line">                <span class="comment">// 删除已选的key,以防重复处理</span></div><div class="line">                iterator.remove();</div><div class="line">                <span class="comment">// 客户端请求连接事件</span></div><div class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                    ServerSocketChannel server = (ServerSocketChannel) key</div><div class="line">                            .channel();</div><div class="line">                    <span class="comment">// 获得和客户端连接的通道</span></div><div class="line">                    SocketChannel channel = server.accept();</div><div class="line">                    <span class="comment">// 设置成非阻塞</span></div><div class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                    <span class="comment">//在这里可以给客户端发送信息</span></div><div class="line">                    channel.write(ByteBuffer.wrap(<span class="string">"向客户端发送了一条信息"</span>.getBytes()));</div><div class="line">                    <span class="comment">//在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。</span></div><div class="line">                    channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</div><div class="line"></div><div class="line">                    <span class="comment">// 获得了可读的事件</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                    read(key);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理读取客户端发来的信息 的事件</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 服务器可读取消息:得到事件发生的Socket通道</span></div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">        <span class="comment">// 创建读取的缓冲区</span></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</div><div class="line">        channel.read(buffer);</div><div class="line">        <span class="keyword">byte</span>[] data = buffer.array();</div><div class="line">        String msg = <span class="keyword">new</span> String(data).trim();</div><div class="line">        System.out.println(<span class="string">"服务端收到信息："</span> + msg);</div><div class="line">        ByteBuffer outBuffer = ByteBuffer.wrap(msg.getBytes());</div><div class="line">        channel.write(outBuffer);<span class="comment">// 将消息回送给客户端</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 启动服务端测试</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        NIOServer server = <span class="keyword">new</span> NIOServer();</div><div class="line">        server.initServer(<span class="number">8000</span>);</div><div class="line">        server.listen();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务端连接过程<br>1、创建ServerSocketChannel实例serverSocketChannel，并bind到指定端口。<br>2、创建Selector实例selector；<br>3、将serverSocketChannel注册到selector，并指定事件OP_ACCEPT。<br>4、while循环执行：<br>4.1、调用select方法，该方法会阻塞等待，直到有一个或多个通道准备好了I/O操作或等待超时。<br>4.2、获取选取的键列表；<br>4.3、循环键集中的每个键：<br>4.3.a、获取通道，并从键中获取附件（如果添加了附件）；<br>4.3.b、确定准备就绪的操纵并执行，如果是accept操作，将接收的信道设置为非阻塞模式，并注册到选择器；<br>4.3.c、如果需要，修改键的兴趣操作集；<br>4.3.d、从已选键集中移除键</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.richstonedt.socket;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Selector;</div><div class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * NIO客户端</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/9/8 21:43</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</div><div class="line">    <span class="comment">//通道管理器</span></div><div class="line">    <span class="keyword">private</span> Selector selector;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得一个Socket通道，并对该通道做一些初始化的工作</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> ip   连接的服务器的ip</div><div class="line">     * <span class="doctag">@param</span> port 连接的服务器的端口号</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">(String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 获得一个Socket通道</span></div><div class="line">        SocketChannel channel = SocketChannel.open();</div><div class="line">        <span class="comment">// 设置通道为非阻塞</span></div><div class="line">        channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 获得一个通道管理器</span></div><div class="line">        <span class="keyword">this</span>.selector = Selector.open();</div><div class="line"></div><div class="line">        <span class="comment">// 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调</span></div><div class="line">        <span class="comment">//用channel.finishConnect();才能完成连接</span></div><div class="line">        channel.connect(<span class="keyword">new</span> InetSocketAddress(ip, port));</div><div class="line">        <span class="comment">//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。</span></div><div class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 轮询访问selector</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            selector.select();</div><div class="line">            <span class="comment">// 获得selector中选中的项的迭代器</span></div><div class="line">            Iterator&lt;SelectionKey&gt; iterator = <span class="keyword">this</span>.selector.selectedKeys().iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                SelectionKey key = iterator.next();</div><div class="line">                <span class="comment">// 删除已选的key,以防重复处理</span></div><div class="line">                iterator.remove();</div><div class="line">                <span class="comment">// 连接事件发生</span></div><div class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</div><div class="line">                    SocketChannel channel = (SocketChannel) key</div><div class="line">                            .channel();</div><div class="line">                    <span class="comment">// 如果正在连接，则完成连接</span></div><div class="line">                    <span class="keyword">if</span> (channel.isConnectionPending()) &#123;</div><div class="line">                        channel.finishConnect();</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 设置成非阻塞</span></div><div class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">                    <span class="comment">//在这里可以给服务端发送信息哦</span></div><div class="line">                    channel.write(ByteBuffer.wrap(<span class="string">"向服务端发送了一条信息"</span>.getBytes()));</div><div class="line">                    <span class="comment">//在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。</span></div><div class="line">                    channel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</div><div class="line"></div><div class="line">                    <span class="comment">// 获得了可读的事件</span></div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">                    read(key);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理读取服务端发来的信息 的事件</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> key</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 客户端可读取消息:得到事件发生的Socket通道</span></div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">        <span class="comment">// 创建读取的缓冲区</span></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</div><div class="line">        channel.read(buffer);</div><div class="line">        <span class="keyword">byte</span>[] data = buffer.array();</div><div class="line">        String msg = <span class="keyword">new</span> String(data).trim();</div><div class="line">        System.out.println(<span class="string">"客户端收到信息："</span> + msg);</div><div class="line">        ByteBuffer outBuffer = ByteBuffer.wrap(msg.getBytes());</div><div class="line">        channel.write(outBuffer);<span class="comment">// 将消息回送给服务端</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 启动客户端测试</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        NIOClient client = <span class="keyword">new</span> NIOClient();</div><div class="line">        client.initClient(<span class="string">"localhost"</span>, <span class="number">8000</span>);</div><div class="line">        client.listen();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端连接过程：(和服务器端类似)<br>1、创建SocketChannel实例socketChannel，并连接到服务器端口<br>2、创建Selector实例selector；<br>3、将socketChannel注册到selector，并指定事件OP_CONNECT。<br>4、while循环执行：<br>4.1、调用select方法，该方法会阻塞等待，直到有一个或多个通道准备好了I/O操作或等待超时。<br>4.2、获取选取的键列表；<br>4.3、循环键集中的每个键：<br>4.3.a、获取通道，并从键中获取附件（如果添加了附件）；<br>4.3.b、确定准备就绪的操纵并执行，如果是accept操作，将接收的信道设置为非阻塞模式，并注册到选择器；<br>4.3.c、如果需要，修改键的兴趣操作集；<br>4.3.d、从已选键集中移除键</p>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>最终这两段代码的运行结果就是客户端和服务器之间不断发送信息<br><strong>server</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">服务端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div></pre></td></tr></table></figure></p>
<p><strong>client</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div><div class="line">客户端收到信息：向服务端发送了一条信息向客户端发送了一条信息</div></pre></td></tr></table></figure></p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>其实Java的NIO使用了IO多路复用，，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<br>目前支持的IO多路复用有select,poll和epoll。<br>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<ol>
<li>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。<br>　　一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<br>　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2>基本原理：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。<br>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</li>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。<br>基本原理：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</li>
</ol>
<p>epoll的优点：</p>
<ol>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。<br>　　只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。<h1 id="epoll原理"><a href="#epoll原理" class="headerlink" title="epoll原理"></a>epoll原理</h1><blockquote>
<p>epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。<br>c封装后的3个epoll系统调用</p>
</blockquote>
</li>
</ol>
<ul>
<li><em>*int epoll_create(int size)</em><br>epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</li>
<li><strong>nt epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong><br>epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。</li>
<li><strong>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)</strong><br>epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。</li>
</ul>
<p>大概看看epoll内部是怎么实现的：</p>
<p>epoll初始化时，会向内核注册一个文件系统，用于存储被监控的句柄文件，调用epoll_create时，会在这个文件系统中创建一个file节点。同时epoll会开辟自己的内核高速缓存区，以红黑树的结构保存句柄，以支持快速的查找、插入、删除。还会再建立一个list链表，用于存储准备就绪的事件。<br>当执行epoll_ctl时，除了把socket句柄放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后，就把socket插入到就绪链表里。<br>当epoll_wait调用时，仅仅观察就绪链表里有没有数据，如果有数据就返回，否则就sleep，超时时立刻返回。<br>epoll的两种工作模式：</p>
<p>LT：level-trigger，水平触发模式，只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket。<br>ET：edge-trigger，边缘触发模式，只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇博客中，我们使用了BIO,也就是阻塞式IO实现了Socket通信。&lt;br&gt;&lt;a href=&quot;http://blog.zgj12138
    
    </summary>
    
      <category term="Java" scheme="https://zgj12138.github.io/blog/categories/Java/"/>
    
    
      <category term="io" scheme="https://zgj12138.github.io/blog/tags/io/"/>
    
      <category term="socket" scheme="https://zgj12138.github.io/blog/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal解析</title>
    <link href="https://zgj12138.github.io/blog/2017/08/18/ThreadLocal%E8%A7%A3%E6%9E%90/"/>
    <id>https://zgj12138.github.io/blog/2017/08/18/ThreadLocal解析/</id>
    <published>2017-08-18T08:33:00.000Z</published>
    <updated>2017-08-19T12:31:27.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在各大公司招聘笔试和面试题题中，都遇到了很多ThreadLocal的问题，最近博主在面试的时候也被两次问到过这个问题，之前也在网上看到过一些此类的文章，其中有很多文章将ThreadLocal与线程同步机制混为一谈，特别注意的是ThreadLocal与线程同步无关，并不是为了解决多线程共享变量问题，我们今天就来研究一下ThreadLocal的原理<br><a id="more"></a></p>
<h1 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h1><p>我们首先来看一下JDK中的源码是怎么写的</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its {@code get} or {@code set} method) has its own, independently initialized copy of the variable. {@code ThreadLocal} instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。</p>
</blockquote>
<p>总结来说就是：<strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</strong><br>ThreadLocal不是为了解决多线程访问共享变量，而是为每个线程创建一个单独的变量副本，提供了保持对象的方法和避免参数传递的复杂性。</p>
<p>ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>ThreadLocal可以看做是一个容器，容器里面存放着属于当前线程的变量。ThreadLocal类提供了四个对外开放的接口方法，这也是用户操作ThreadLocal类的基本方法：</p>
<ul>
<li><p><code>public void set(Object value)</code>设置当前线程的线程局部变量的值。 </p>
</li>
<li><p><code>public Object get()</code>该方法返回当前线程所对应的线程局部变量。 </p>
</li>
<li><p><code>public void remove()</code>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 </p>
</li>
<li><code>protected Object initialValue()</code>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次，ThreadLocal中的缺省实现直接返回一个null。</li>
</ul>
<p>可以通过上述的几个方法实现ThreadLocal中变量的访问，数据设置，初始化以及删除局部变量，那ThreadLocal内部是如何为每一个线程维护变量副本的呢？</p>
<p>其实在ThreadLocal类中有一个静态内部类ThreadLocalMap(其类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本，每个线程可能存在多个ThreadLocal。</p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();<span class="comment">//当前线程</span></div><div class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//获取当前线程对应的ThreadLocalMap</span></div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//获取对应ThreadLocal的变量值</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();<span class="comment">//若当前线程还未创建ThreadLocalMap，则返回调用此方法并在其中调用createMap方法进行创建并返回初始值。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//设置变量的值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">   Thread t = Thread.currentThread();</div><div class="line">   ThreadLocalMap map = getMap(t);</div><div class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">       map.set(<span class="keyword">this</span>, value);</div><div class="line">   <span class="keyword">else</span></div><div class="line">       createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="setInitialValue-方法"><a href="#setInitialValue-方法" class="headerlink" title="setInitialValue()方法"></a>setInitialValue()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">   T value = initialValue();</div><div class="line">   Thread t = Thread.currentThread();</div><div class="line">   ThreadLocalMap map = getMap(t);</div><div class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">       map.set(<span class="keyword">this</span>, value);</div><div class="line">   <span class="keyword">else</span></div><div class="line">       createMap(t, value);</div><div class="line">   <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="createMap-方法"><a href="#createMap-方法" class="headerlink" title="createMap()方法"></a>createMap()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">为当前线程创建一个ThreadLocalMap的threadlocals,并将第一个值存入到当前map中</div><div class="line"><span class="doctag">@param</span> t the current thread</div><div class="line"><span class="doctag">@param</span> firstValue value for the initial entry of the map</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除当前线程中ThreadLocalMap对应的ThreadLocal</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">       ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">       <span class="keyword">if</span> (m != <span class="keyword">null</span>)</div><div class="line">           m.remove(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap是定制的hashMap，仅用于维护当前线程的本地变量值。仅ThreadLocal类对其有操作权限，是Thread的私有属性。为避免占用空间较大或生命周期较长的数据常驻于内存引发一系列问题，hash table的key是弱引用WeakReferences。当空间不足时，会清理未被引用的entry。</p>
<p>getMap(t)返回当前线程的成员变量ThreadLocalMap（Thread的成员变量有ThreadLocalMap，这一点可以查看Thread的源码，如下）很明确的说明了ThreadLocal属于线程，ThreadLocalMap由ThreadLocal持有，说到底，ThreadLocalMap 也是线程所持有。每个线程Thread都有自己的ThreadLocalMap。<br>下面看一下该类的源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line">  <span class="comment">//map中的每个节点Entry,其键key是ThreadLocal并且还是弱引用，这也导致了后续会产生内存泄漏问题的原因。</span></div><div class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">           Object value;</div><div class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">               <span class="keyword">super</span>(k);</div><div class="line">               value = v;</div><div class="line">   &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化容量为16，以为对其扩充也必须是2的指数 </div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 真正用于存储线程的每个ThreadLocal的数组，将ThreadLocal和其对应的值包装为一个Entry。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Entry[] table;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">///....其他的方法和操作都和map的类似</span></div></pre></td></tr></table></figure></p>
<h1 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h1><ol>
<li>ThreadLocal并未解决多线程访问共享对象的问题；</li>
<li>ThreadLocal并不是每个线程拷贝一个对象，而是直接new（新建）一个；</li>
<li>如果ThreadLocal.set()的对象是多线程共享的，那么还是涉及并发问题。</li>
</ol>
<h1 id="ThreadLocal的内存泄漏"><a href="#ThreadLocal的内存泄漏" class="headerlink" title="ThreadLocal的内存泄漏"></a>ThreadLocal的内存泄漏</h1><p>在上面提到过，每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收. 但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收。</p>
<p>所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在各大公司招聘笔试和面试题题中，都遇到了很多ThreadLocal的问题，最近博主在面试的时候也被两次问到过这个问题，之前也在网上看到过一些此类的文章，其中有很多文章将ThreadLocal与线程同步机制混为一谈，特别注意的是ThreadLocal与线程同步无关，并不是为了解决多线程共享变量问题，我们今天就来研究一下ThreadLocal的原理&lt;br&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://zgj12138.github.io/blog/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="threadlocal" scheme="https://zgj12138.github.io/blog/tags/threadlocal/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之——原型模式</title>
    <link href="https://zgj12138.github.io/blog/2017/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zgj12138.github.io/blog/2017/08/05/设计模式之—原型模式/</id>
    <published>2017-08-04T16:03:11.000Z</published>
    <updated>2017-08-08T16:09:06.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Java 中，我们可以使用 new 关键字指定类名来生成类的实例。但是，有的时候，我们也会在不指定类名的前提下生成实例，例如像图形编辑器中拖动现有的模型工具制作图形的实例，这种是非常典型的生成实例的过程太过复杂，很难根据类来生成实例场景，因此需要根据现有的实例来生成新的实例。<br>像这样根据实例来生成新的实例的模式，我们称之为 <strong>原型模式</strong>。<br>在软件开发过程中，我们经常会遇到需要创建多个相同或者相似对象的情况，因此 <strong>原型模式</strong> 的使用频率还是很高的。<br><a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>定义：</strong> 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。<br><strong>类型：</strong> 类的创建模式</p>
<h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>在原型模式中涉及 <code>Prototype</code>、 <code>ConcretePrototype</code>、 <code>Client</code> 三个角色。<br><img src="https://i.loli.net/2017/08/04/59847a11d0683.png" alt="prototype.png"><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * 2017/8/4 21:46</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="function">Prototype <span class="title">clone</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String attr; <span class="comment">// 成员属性</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 克隆方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ConcretePrototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 创建新对象</span></div><div class="line">        ConcretePrototype prototype = <span class="keyword">new</span> ConcretePrototype();</div><div class="line">        prototype.setAttr(<span class="keyword">this</span>.attr);</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"ConcretePrototype[attr="</span> + attr + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttr</span><span class="params">(String attr)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.attr = attr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAttr</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attr;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ConcretePrototype prototype = <span class="keyword">new</span> ConcretePrototype();</div><div class="line">        prototype.setAttr(<span class="string">"Kevin Zhang"</span>);</div><div class="line"></div><div class="line">        ConcretePrototype prototype2 = prototype.clone();</div><div class="line"></div><div class="line">        System.out.println(prototype.toString());</div><div class="line">        System.out.println(prototype2.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ConcretePrototype[attr=Kevin Zhang]</div><div class="line">ConcretePrototype[attr=Kevin Zhang]</div><div class="line"></div><div class="line">Process finished with exit code 0</div></pre></td></tr></table></figure></p>
<h1 id="Java的原型模式"><a href="#Java的原型模式" class="headerlink" title="Java的原型模式"></a>Java的原型模式</h1><p>Java 中使用原型模式很简单， 它为我们提供了复制实例的 <code>clone()</code> 方法。</p>
<p>实际上，所有的 Java 类都继承自 <code>java.lang.Object。Object</code> 类提供一个 <code>clone()</code> 方法，因此，在 Java 中可以直接使用 Object 提供的 <code>clone()</code> 方法来实现对象的克隆。</p>
<p>值得注意的是，被复制对象的类必须实现 java.lang.Cloneable 接口，如果没有实现 <code>java.lang.Cloneable</code> 接口的实例调用了 <code>clone()</code> 方法，会在运行时抛出<code>CloneNotSupportedException</code> 异常。</p>
<p><code>Cloneable</code> 是一个标记接口，在 <code>Cloneable</code> 接口中并没有声明任何方法，它只是被用来标记可以使用 <code>clone()</code> 方法进行复制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>现在，我有一个消息系统的需求，希望复制原先消息模板进行快速创建，然后可以进行修改后保存。</p>
<p>下面，我们通过 Java 的 clone()方法来实现对象的克隆。</p>
<p>Message 就是具体原型类，复制实现 clone() 方法。<br>Message代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/8/4 21:56</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String author;</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> author;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        Message message = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            message = (Message) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Message&#123;"</span> +</div><div class="line">                <span class="string">"author='"</span> + author + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", content='"</span> + content + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Client代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/8/4 22:00</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Message message = <span class="keyword">new</span> Message();</div><div class="line">        message.setAuthor(<span class="string">"ZGJ"</span>);</div><div class="line">        message.setContent(<span class="string">"2017-08-04【消息】"</span>);</div><div class="line"></div><div class="line">        Message message1 = (Message) message.clone();</div><div class="line">        message.setContent(<span class="string">"2017-08-05【消息】"</span>);</div><div class="line"></div><div class="line">        System.out.println(message);</div><div class="line">        System.out.println(message1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Message&#123;author=&apos;ZGJ&apos;, content=&apos;2017-08-05【消息】&apos;&#125;</div><div class="line">Message&#123;author=&apos;ZGJ&apos;, content=&apos;2017-08-04【消息】&apos;&#125;</div></pre></td></tr></table></figure></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>既然要创建新的实例，为什么不直接使用 new XXX()，而要设计出一个原型模式进行实例的复制呢？</p>
<p>有的时候，我们也会在不指定类名的前提下生成实例，例如像图形编辑器中拖动现有的模型工具制作图形的实例，这种是非常典型的生成实例的过程太过复杂，很难根据类来生成实例场景，因此需要根据现有的实例来生成新的实例。<br>Prototype原型模式是一种创建型设计模式，它主要面对的问题是：“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</p>
<p>还比如，类初始化需要消化非常多的资源，我们也可以考虑使用原型模式。因为，原型模式是在内存进行二进制流的拷贝，要比直接 new 一个对象性能好很多。</p>
<h2 id="克隆的对象是全新的吗？"><a href="#克隆的对象是全新的吗？" class="headerlink" title="克隆的对象是全新的吗？"></a>克隆的对象是全新的吗？</h2><p>原型模式通过 clone() 方法创建的对象是全新的对象,它在内存中拥有新的地址,通过==符号判断返回是flase。</p>
<h2 id="深克隆和浅克隆"><a href="#深克隆和浅克隆" class="headerlink" title="深克隆和浅克隆"></a>深克隆和浅克隆</h2><p>clone() 方法使用的是浅克隆。浅克隆对于要克隆的对象, 会复制其基本数据类型和 String 类型或其他final类型的属性的值给新的对象. 而对于非基本数据类型的属性，例如数组、集合, 仅仅复制一份引用给新产生的对象, 即新产生的对象和原始对象中的非基本数据类型的属性都指向的是同一个对象。</p>
<p>此外，还存在深克隆。深克隆对于要克隆的对象, 对于非基本数据类型的属性，例如数组、集合支持复制。换句话说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
<p>浅克隆和深克隆的主要区别在于，是否支持引用类型的成员变量的复制。</p>
<p>在 Java 中，如果需要实现深克隆，可以通过序列化等方式来实现。<br>我们在消息中增加一个附件类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/8/4 22:10</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Attachment&#123;"</span> +</div><div class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在消息中加入这个附件类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * 2017/8/4 21:56</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line">    <span class="keyword">private</span> String author;</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line">    <span class="keyword">private</span> Attachment attachment;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> author;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.author = author;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Attachment <span class="title">getAttachment</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> attachment;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttachment</span><span class="params">(Attachment attachment)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.attachment = attachment;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 将对象序列化到对象数组流中</div><div class="line">         */</div><div class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</div><div class="line">        oos.writeObject(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 从流中读取对象</div><div class="line">         */</div><div class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</div><div class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</div><div class="line">        <span class="keyword">return</span> (Message) ois.readObject();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用序列化实现深度克隆，然后再客户端中测试是否深度克隆成功<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/8/4 22:30</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Message message = <span class="keyword">new</span> Message();</div><div class="line">        message.setAuthor(<span class="string">"ZGJ"</span>);</div><div class="line">        message.setContent(<span class="string">"2017-08-04【消息】"</span>);</div><div class="line">        Attachment attachment = <span class="keyword">new</span> Attachment();</div><div class="line">        attachment.setName(<span class="string">"附件"</span>);</div><div class="line">        message.setAttachment(attachment);</div><div class="line">        Message message1 = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            message1 = message.deepClone();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            System.out.println(<span class="string">"克隆失败"</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"消息是否相同："</span> + (message == message1));</div><div class="line">        System.out.println(<span class="string">"附件是否相同："</span> + (message.getAttachment() == message1.getAttachment()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">消息是否相同：false</div><div class="line">附件是否相同：false</div></pre></td></tr></table></figure></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>一般而言，Java语言中的clone()方法满足：</p>
<ol>
<li>对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</li>
<li>对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</li>
<li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li>
</ol>
<p>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</p>
<ol>
<li>在派生类中覆盖基类的clone()方法，并声明为public；</li>
<li>在派生类的clone()方法中，调用super.clone()；<br>3.派生类需实现Cloneable接口。<br>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原型模式的目的在于，根据实例来生成新的实例，我们可以很方便的快速的创建实例。</p>
<p>在 Java 中使用原型模式很简单， 被复制对象的类必须实现 java.lang.Cloneable 接口，并重写 clone() 方法。</p>
<p>使用原型模式的时候，尤其需要注意浅克隆和深克隆问题。在 Java 中，如果需要实现深克隆，可以通过序列化等方式来实现</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Java 中，我们可以使用 new 关键字指定类名来生成类的实例。但是，有的时候，我们也会在不指定类名的前提下生成实例，例如像图形编辑器中拖动现有的模型工具制作图形的实例，这种是非常典型的生成实例的过程太过复杂，很难根据类来生成实例场景，因此需要根据现有的实例来生成新的实例。&lt;br&gt;像这样根据实例来生成新的实例的模式，我们称之为 &lt;strong&gt;原型模式&lt;/strong&gt;。&lt;br&gt;在软件开发过程中，我们经常会遇到需要创建多个相同或者相似对象的情况，因此 &lt;strong&gt;原型模式&lt;/strong&gt; 的使用频率还是很高的。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zgj12138.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://zgj12138.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>学习总结 2017-08</title>
    <link href="https://zgj12138.github.io/blog/2017/08/03/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932017-08/"/>
    <id>https://zgj12138.github.io/blog/2017/08/03/学习总结2017-08/</id>
    <published>2017-08-03T12:10:00.000Z</published>
    <updated>2017-09-10T00:45:38.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录个人在2017年08月的学习和总结，不定期更新<br><a id="more"></a></p>
<h1 id="2017-08-02"><a href="#2017-08-02" class="headerlink" title="2017-08-02"></a>2017-08-02</h1><h2 id="有序的Map"><a href="#有序的Map" class="headerlink" title="有序的Map"></a>有序的Map</h2><p>HashMap是无序的，有序的Map是TreeMap和LinkedHashMap,TreeMap里的元素排序要key实现Comparable接口或者传入一个Comparator比较器，LinkedHashMap里面元素的顺序和插入的顺序一致<br>效率比较：<br>TreeMap采用红黑树的数据结构实现，而LinkedHashMap采用链表的方式实现，查找效率上来说TreeMap会比LinkedHashMap高</p>
<h2 id="TCP创建连接和断开连接的过程"><a href="#TCP创建连接和断开连接的过程" class="headerlink" title="TCP创建连接和断开连接的过程"></a>TCP创建连接和断开连接的过程</h2><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ul>
<li>三次握手</li>
<li>四次挥手</li>
<li>可靠连接</li>
<li>丢包重传</li>
</ul>
<p>核心：<strong>tcp是可以可靠传输协议，它的所有特点都为这个可靠传输服务</strong>。</p>
<h3 id="创建连接时的三次握手"><a href="#创建连接时的三次握手" class="headerlink" title="创建连接时的三次握手"></a>创建连接时的三次握手</h3><p>来看一个java代码连接数据库的三次握手过程<br><img src="https://ooo.0o0.ooo/2017/08/03/5983265998b9b.png" alt="tcp握手.png"></p>
<ul>
<li>第一步：client 发送 syn 到server 发起握手；</li>
<li>第二步：server 收到 syn后回复syn+ack给client；</li>
<li>第三步：client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack（此时client的48287端口的连接已经是established）<br>握手的核心目的是告知对方seq（绿框是client的初始seq，蓝色框是server 的初始seq），对方回复ack（收到的seq+包的大小），这样发送端就知道有没有丢包了。</li>
</ul>
<p>握手的次要目的是告知和协商一些信息，图中黄框。</p>
<p>MSS–最大传输包<br>SACK_PERM–是否支持Selective ack(用户优化重传效率）<br>WS–窗口计算指数（有点复杂的话先不用管）<br>这就是tcp为什么要握手建立连接，就是为了解决tcp的可靠传输。</p>
<h3 id="断开连接时的四次挥手"><a href="#断开连接时的四次挥手" class="headerlink" title="断开连接时的四次挥手"></a>断开连接时的四次挥手</h3><p>再来看java连上mysql后，执行了一个SQL： select sleep(2); 然后就断开了连接<br>四个红框表示断开连接的四次挥手：<br><img src="https://i.loli.net/2017/08/03/59832659b242d.png" alt="tcp挥手.png"><br>第一步： client主动发送fin包给server<br>第二步： server回复ack（对应第一步fin包的ack）给client，表示server知道client要断开了<br>第三步： server发送fin包给client，表示server也可以断开了<br>第四部： client回复ack给server，表示既然双发都发送fin包表示断开，那么就真的断开吧</p>
<h4 id="为什么是握手是三次而挥手是四次"><a href="#为什么是握手是三次而挥手是四次" class="headerlink" title="为什么是握手是三次而挥手是四次"></a>为什么是握手是三次而挥手是四次</h4><p>这是因为当client发送fin包给服务器的时候，server可能还需要有一些后续工作要做，比如OS通知应用层要关闭，这里应用层可能需要做些准备工作，或者说server还有一些数据需要发送给client，等准备工作做完或者是数据发送完毕，就可以发送fin包了</p>
<hr>
<h1 id="2017-08-03"><a href="#2017-08-03" class="headerlink" title="2017-08-03"></a>2017-08-03</h1><h2 id="JVM-参数初探"><a href="#JVM-参数初探" class="headerlink" title="JVM 参数初探"></a>JVM 参数初探</h2><h3 id="堆参数"><a href="#堆参数" class="headerlink" title="堆参数"></a>堆参数</h3><p>-XX:+PrintGC 使用这个参数，虚拟机启动后，只要遇到GC就会打印日志<br>-XX:+UseSerialGC 配置串行回收器<br>-XX:+PrintGCDetails 可以查看详细信息，包括各个区的情况<br>-Xms 设置最小堆<br>-Xmx 设置最大堆<br>-Xmx20m -Xms5m -XX:+PrintCommandLineFlags 可以将隐式或者显示传递给虚拟机的参数输出，打印虚拟机配置</p>
<p>★技巧：JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最 大分配的内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70% 时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。</p>
<h3 id="新生代配置"><a href="#新生代配置" class="headerlink" title="新生代配置"></a>新生代配置</h3><p>-Xmn 可以设置新生代的大小，设置一个比较大的新生代会减少老年代的大小，这个参数对系统性能以及GC行为有很大的影响，新生代GC频繁，老年代相对少，新生代大小一般会设置整合堆空间的1/3到1/4左右。<br>-XX:SurvivorRatio 用来设置新生代中eden区和from/to区的比例，默认8:1:1<br>含义：-XX:SurvivorRatio=eden/from=eden/to<br>★技巧：不同的堆分布情况，对系统执行会产生一定影响，在实际情况下，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。<br>除了可以设置新生代的绝对大小-Xmn，还可以使用-XX:NewRatio来设置新生代和老年代的比例：-XX:NewRatio=新生代/老年代</p>
<h3 id="堆溢出处理"><a href="#堆溢出处理" class="headerlink" title="堆溢出处理"></a>堆溢出处理</h3><p>堆溢出处理<br>在Java程序的运行过程中，如果堆空间不足，则会抛出内存溢出的错误Out of Memory（OOM），一旦这类问题发生在生产环境，就可能引起严重的业务中断，java虚拟机提供了-XX:HeapDumpOnOutOfMemoryError，使用该参数可以在内存溢出时导出整个堆信息，与之配合使用的还有参数。<br>-XX:HeapDumpPath，可以设置导出堆的存放路径<br>内存分析工具：Memory Analyzer</p>
<p>dump信息：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/Test03.dump</p>
<h3 id="栈参数"><a href="#栈参数" class="headerlink" title="栈参数"></a>栈参数</h3><p>-Xss 指定线程最大栈空间，整合参数也直接决定了函数可调用的最大深度</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>JDK8以前，方法区和java堆一样，是一块所有线程共享的内存区域，它用于保存系统的类信息，方法区（永久区）可以保存多少信息可以对其进行配置，在默认情况下，-XX:MaxPermSize为64M，如果系统运行时产生大量的类，就需要设置一个相对合适的方法区，以免出现永久区0内存溢出的问题。<br>-XX:MaxPermSize=64M -XX:PermSize=64M<br>jdk1.7以后不分client或者server模式</p>
<p>JDK8以后，永久区被移除，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p>
<hr>
<h1 id="2017-08-04"><a href="#2017-08-04" class="headerlink" title="2017-08-04"></a>2017-08-04</h1><h2 id="Spring-IOC和AOP"><a href="#Spring-IOC和AOP" class="headerlink" title="Spring IOC和AOP"></a>Spring IOC和AOP</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>降低了组件之间的耦合性 ，实现了软件各层之间的解耦</li>
<li>可以使用容易提供的众多服务，如事务管理，消息服务等</li>
<li>容器提供单例模式支持</li>
<li>容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能</li>
<li>容器提供了众多的辅助类，能加快应用的开发</li>
<li>spring对于主流的应用框架提供了集成支持，如hibernate，JPA，struts等</li>
<li>spring属于低侵入式设计，代码的污染极低</li>
<li>独立于各种应用服务器</li>
<li>spring的DI机制降低了业务对象替换的复杂性</li>
<li>spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部</li>
</ol>
<h3 id="根本目的"><a href="#根本目的" class="headerlink" title="根本目的"></a>根本目的</h3><p>根本目的：简化Java开发。<br>为了降低Java开发的复杂性，Spring采取以下4种关键策略：</p>
<ul>
<li>基于POJO的轻量级和最小侵入性编程</li>
<li>通过依赖注入和面向接口实现松耦合</li>
<li>基于切面和惯例进行声明式编程</li>
<li>通过切面和模版减少样板示代码</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<p>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
<p>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<h4 id="IoC能做什么"><a href="#IoC能做什么" class="headerlink" title="IoC能做什么"></a>IoC能做什么</h4><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h5 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h5><p>DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li><p>谁依赖于谁：当然是应用程序依赖于IoC容器；</p>
</li>
<li><p>为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p>
</li>
<li><p>谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>
</li>
<li><p>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
</li>
</ul>
<p>　　IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><p>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>AOP用来封装横切关注点，具体可以在下面的场景中使用:</p>
<ul>
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　懒加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li>
<li>Performance optimization　性能优化</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
<li>Transactions 事务</li>
</ul>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>首先让我们从一些重要的AOP概念和术语开始。这些术语不是Spring特有的。不过AOP术语并不是特别的直观，如果Spring使用自己的术语，将会变得更加令人困惑。</p>
<ul>
<li><p>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式）或者基于@Aspect注解的方式来实现。</p>
</li>
<li><p>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。</p>
</li>
<li><p>通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</p>
</li>
<li><p>切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</p>
</li>
<li><p>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</p>
</li>
<li><p>目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</p>
</li>
<li><p>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
</li>
<li><p>织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
</li>
</ul>
<p><strong>通知类型：</strong></p>
<ul>
<li><p>前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p>
</li>
<li><p>后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p>
</li>
<li><p>异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。</p>
</li>
<li><p>最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
</li>
<li><p>环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p>
</li>
</ul>
<p>环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知，我们推荐你使用尽可能简单的通知类型来实现需要的功能。例如，如果你只是需要一个方法的返回值来更新缓存，最好使用后置通知而不是环绕通知，尽管环绕通知也能完成同样的事情。用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。比如，你不需要在JoinPoint上调用用于环绕通知的proceed()方法，就不会有调用的问题。</p>
<hr>
<h1 id="2017-08-06"><a href="#2017-08-06" class="headerlink" title="2017-08-06"></a>2017-08-06</h1><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。</p>
<h3 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h3><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<hr>
<h1 id="2017-08-07"><a href="#2017-08-07" class="headerlink" title="2017-08-07"></a>2017-08-07</h1><h2 id="Java栈上分配对象"><a href="#Java栈上分配对象" class="headerlink" title="Java栈上分配对象"></a>Java栈上分配对象</h2><p>我们在学习使用Java的过程中，一般认为new出来的对象都是被分配在堆上，但是这个结论不是那么的绝对，通过对Java对象分配的过程分析，可以知道有两个地方会导致Java中new出来的对象并不一定分别在所认为的堆上。这两个点分别是Java中的逃逸分析和TLAB（Thread Local Allocation Buffer）</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。<br>在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。<br>Java在java SE 6u23以及以后的版本中支持并默认开启了逃逸分析的选项。Java的 HotSpot JIT编译器，能够在方法重载或者动态加载代码的时候对代码进行逃逸分析，同时Java对象在堆上分配和内置线程的特点使得逃逸分析成Java的重要功能。</p>
<h4 id="逃逸分析的方法"><a href="#逃逸分析的方法" class="headerlink" title="逃逸分析的方法"></a>逃逸分析的方法</h4><p>Java Hotspot编译器使用的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Choi J D, Gupta M, Serrano M, et al. Escape analysis for Java[J]. Acm Sigplan Notices, 1999, 34(10): 1-19.</div></pre></td></tr></table></figure></p>
<p>Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff等在论文《Escape Analysis for Java》中描述的算法进行逃逸分析的。该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。<br>绝大多数逃逸分析的实现都基于一个所谓“封闭世界(closed world)”的前提：所有可能被执行的，方法在做逃逸分析前都已经得知，并且，程序的实际运行不会改变它们之间的调用关系 。但当真实的 Java 程序运行时，这样的假设并不成立。Java 程序拥有的许多特性，例如动态类加载、调用本地函数以及反射程序调用等等，都将打破所谓“封闭世界”的约定。 </p>
<h4 id="逃逸分析后的处理"><a href="#逃逸分析后的处理" class="headerlink" title="逃逸分析后的处理"></a>逃逸分析后的处理</h4><p>经过逃逸分析之后，可以得到三种对象的逃逸状态。</p>
<ol>
<li>GlobalEscape（全局逃逸）， 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。</li>
<li>ArgEscape（参数级逃逸），即在方法调用过程当中传递对象的引用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。</li>
<li>NoEscape（没有逃逸），一个可以进行标量替换的对象。可以不将这种对象分配在传统的堆上。<br>编译器可以使用逃逸分析的结果，对程序进行一下优化。</li>
<li>堆分配对象变成栈分配对象。一个方法当中的对象，对象的引用没有发生逃逸，那么这个方法可能会被分配在栈内存上而非常见的堆内存上。</li>
<li>消除同步。线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。</li>
<li>矢量替代。逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。</li>
</ol>
<p>下面，我们看一下逃逸分析的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">    example();  </div><div class="line">  &#125;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;  </div><div class="line">    Foo foo = <span class="keyword">new</span> Foo(); <span class="comment">//alloc  </span></div><div class="line">    Bar bar = <span class="keyword">new</span> Bar(); <span class="comment">//alloc  </span></div><div class="line">    bar.setFoo(foo);  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;  </div><div class="line">   </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;  </div><div class="line">  <span class="keyword">private</span> Foo foo;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoo</span><span class="params">(Foo foo)</span> </span>&#123;  </div><div class="line">    <span class="keyword">this</span>.foo = foo;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子当中，我们创建了两个对象，Foo对象和Bar对象，同时我们把Foo对象的应用赋值给了Bar对象的方法。此时，如果Bar对在堆上就会引起Foo对象的逃逸，但是，在本例当中，编译器通过逃逸分析，可以知道Bar对象没有逃出example()方法，因此这也意味着Foo也没有逃出example方法。因此，编译器可以将这两个对象分配到栈上。</p>
<h4 id="编译器经过逃逸分析的效果"><a href="#编译器经过逃逸分析的效果" class="headerlink" title="编译器经过逃逸分析的效果"></a>编译器经过逃逸分析的效果</h4><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;  </div><div class="line">            x = (++counter);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">long</span> start = System.nanoTime();  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">10</span>; ++i) &#123;  </div><div class="line">            Foo foo = <span class="keyword">new</span> Foo();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">long</span> end = System.nanoTime();  </div><div class="line">        System.out.println(<span class="string">"Time cost is "</span> + (end - start));  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>未开启逃逸分析设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-server -verbose:gc</div></pre></td></tr></table></figure></p>
<p>开启逃逸分析设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-server -verbose:gc -XX:+DoEscapeAnalysis</div></pre></td></tr></table></figure></p>
<p>在未开启逃逸分析的状况下运行情况如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[GC 5376K-&gt;427K(63872K), 0.0006051 secs]  </div><div class="line">[GC 5803K-&gt;427K(63872K), 0.0003928 secs]  </div><div class="line">[GC 5803K-&gt;427K(63872K), 0.0003639 secs]  </div><div class="line">[GC 5803K-&gt;427K(69248K), 0.0003770 secs]  </div><div class="line">[GC 11179K-&gt;427K(69248K), 0.0003987 secs]  </div><div class="line">[GC 11179K-&gt;427K(79552K), 0.0003817 secs]  </div><div class="line">[GC 21931K-&gt;399K(79552K), 0.0004342 secs]  </div><div class="line">[GC 21903K-&gt;399K(101120K), 0.0002175 secs]  </div><div class="line">[GC 43343K-&gt;399K(101184K), 0.0001421 secs]  </div><div class="line">Time cost is 58514571</div></pre></td></tr></table></figure></p>
<p>开启逃逸分析的状况下，运行情况如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time cost is 10031306</div></pre></td></tr></table></figure></p>
<p>未开启逃逸分析时，运行上诉代码，JVM执行了GC操作，而在开启逃逸分析情况下，JVM并没有执行GC操作。同时，操作时间上，开启逃逸分析的程序运行时间是未开启逃逸分析时间的1/5。</p>
<h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><p>JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。<br>也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。<br>关于对象分配的JDK源码可以参见JVM 之 Java对象创建[初始化]中对OpenJDK源码的分析。</p>
<h3 id="Java对象分配的过程"><a href="#Java对象分配的过程" class="headerlink" title="Java对象分配的过程"></a>Java对象分配的过程</h3><p>编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.<br>如果tlab_top + size &lt;= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.<br>重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4.<br>在Eden区加锁（这个区是多线程共享的），如果eden_top + size &lt;= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5.<br>执行一次Young GC（minor collection）。<br>经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。<br>对象不在堆上分配主要的原因还是堆是共享的，在堆上分配有锁的开销。无论是TLAB还是栈都是线程私有的，私有即避免了竞争（当然也可能产生额外的问题例如可见性问题），这是典型的用空间换效率的做法。</p>
<hr>
<h1 id="2017-08-08"><a href="#2017-08-08" class="headerlink" title="2017-08-08"></a>2017-08-08</h1><h2 id="UnSafe类"><a href="#UnSafe类" class="headerlink" title="UnSafe类"></a>UnSafe类</h2><p>JDK源码中，在研究AQS框架时，会发现很多地方都使用了CAS操作，在并发实现中CAS操作必须具备原子性，而且是硬件级别的原子性，Java被隔离在硬件之上，明显力不从心，这时为了能直接操作操作系统层面，肯定要通过用C++编写的native本地方法来扩展实现。JDK提供了一个类来满足CAS的要求，sun.misc.Unsafe，从名字上可以大概知道它用于执行低级别、不安全的操作，AQS就是使用此类完成硬件级别的原子操作。</p>
<p>Unsafe是一个很强大的类，它可以分配内存、释放内存、可以定位对象某字段的位置、可以修改对象的字段值、可以使线程挂起、使线程恢复、可进行硬件级别原子的CAS操作等等，但平时我们没有这么特殊的需求去使用它，而且必须在受信任代码（一般由JVM指定）中调用此类，例如直接Unsafe unsafe = Unsafe.getUnsafe();获取一个Unsafe实例是不会成功的，因为这个类的安全性很重要，设计者对其进行了如下判断，它会检测调用它的类是否由启动类加载器Bootstrap ClassLoader（它的类加载器为null）加载，由此保证此类只能由JVM指定的类使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static Unsafe getUnsafe() &#123;  </div><div class="line">   Class cc = sun.reflect.Reflection.getCallerClass(2);  </div><div class="line">   if (cc.getClassLoader() != null)  </div><div class="line">       throw new SecurityException(&quot;Unsafe&quot;);  </div><div class="line">   return theUnsafe;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然可以通过反射绕过上面的限制，用下面的getUnsafeInstance方法可以获取Unsafe实例，这段代码演示了如何获取java对象的相对地址偏移量及使用Unsafe完成CAS操作，最终输出的是flag字段的内存偏移量及CAS操作后的值。分别为12和101。另外如果使用开发工具如Eclipse，可能会编译通不过，只要把编译错误提示关掉即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.example.demo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> sun.misc.Unsafe;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhangguoji</div><div class="line"> * <span class="doctag">@date</span> 2017/8/8 11:46</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">100</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> offset;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            unsafe = getUnsafeInstance();</div><div class="line">            offset = unsafe.objectFieldOffset(UnsafeTest.class</div><div class="line">                    .getDeclaredField(<span class="string">"flag"</span>));</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> expect = <span class="number">100</span>;</div><div class="line">        <span class="keyword">int</span> update = <span class="number">101</span>;</div><div class="line">        UnsafeTest unsafeTest = <span class="keyword">new</span> UnsafeTest();</div><div class="line">        System.out.println(<span class="string">"unsafeTest对象的flag字段的地址偏移量为："</span> + offset);</div><div class="line">        unsafeTest.doSwap(offset, expect, update);</div><div class="line">        System.out.println(<span class="string">"CAS操作后的flag值为："</span> + unsafeTest.getFlag());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doSwap</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, offset, expect, update);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafeInstance</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException,</span></div><div class="line">            NoSuchFieldException, IllegalArgumentException,</div><div class="line">            IllegalAccessException &#123;</div><div class="line">        Field theUnsafeInstance = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">        theUnsafeInstance.setAccessible(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> (Unsafe) theUnsafeInstance.get(Unsafe.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unsafeTest对象的flag字段的地址偏移量为：12</div><div class="line">CAS操作后的flag值为：101</div></pre></td></tr></table></figure></p>
<p>Unsafe类让我们明白了java是如何实现对操作系统操作的，一般我们使用java是不需要在内存中处理java对象及内存地址位置的，但有的时候我们确实需要知道java对象相关的地址，于是我们使用Unsafe类，尽管java对其提供了足够的安全管理。</p>
<p>Java语言的设计者们极力隐藏涉及底层操作系统的相关操作，但此节我们本着对AQS框架实现的目的，不得不剖析了Unsafe类，因为AQS里面即是使用Unsafe获取对象字段的地址偏移量、相关原子操作来实现CAS操作的。</p>
<h2 id="MySQL-value和vlues的区别"><a href="#MySQL-value和vlues的区别" class="headerlink" title="MySQL value和vlues的区别"></a>MySQL value和vlues的区别</h2><p>两者功能一样，可以混合使用，但是value插入多条数据时性能较好，values插入单条数据时性能较好，跟我们的逻辑相反的，很奇怪<br>单是SQL Sever只能使用values</p>
<h2 id="ConcurrentHashMap跨版本问题"><a href="#ConcurrentHashMap跨版本问题" class="headerlink" title="ConcurrentHashMap跨版本问题"></a>ConcurrentHashMap跨版本问题</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="javac"><a href="#javac" class="headerlink" title="javac"></a>javac</h4><p>javac有两个指令：-source和-target，比如下述指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/lib/java/jdk1.8.0_131/bin/javac -source 1.7 -target 1.7 HelloWorld.java</div></pre></td></tr></table></figure></p>
<p>-source：表示我的代码将采用哪个java版本来编译。该值影响的是编译器对语法规则的校验。比如HelloWorld.java中含有jdk8的语法，但是你的-source为1.7，那么编译器就会报错。</p>
<p>-target：表示生成的字节码将会在哪个版本（及以上）的jvm上运行。比如HelloWorld.java指定了-target为1.8，那么HelloWorld.class只能在1.8即以上的jvm中运行，如果在1.7的jvm上运行，就会报错。</p>
<h4 id="rt-jar"><a href="#rt-jar" class="headerlink" title="rt.jar"></a>rt.jar</h4><p>jdk的rt.jar里面包含了jdk的核心类，比如String，集合等。JVM在加载类时，对于rt.jar包里面的所有的类持有最高的信任而不做任何校验。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code>类有一个方法叫做<code>keySet</code>，用来返回当前map中的key集合。虽然返回的是key的集合，但是在1.7和1.8中用来表示该集合的类却完全不同。在1.7中，返回的是<code>Set</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Set&lt;K&gt; More ...keySet() &#123;</div><div class="line">    Set&lt;K&gt; ks = keySet;</div><div class="line">    <span class="keyword">return</span> (ks != <span class="keyword">null</span>) ? ks : (keySet = <span class="keyword">new</span> KeySet());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然而在1.8中返回的是<code>KeySetView</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> KeySetView&lt;K,V&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</div><div class="line">    KeySetView&lt;K,V&gt; ks;</div><div class="line">    <span class="keyword">return</span> (ks = keySet) != <span class="keyword">null</span> ? ks : (keySet = <span class="keyword">new</span> KeySetView&lt;K,V&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>KeySetView</code>其实是Set接口的一个实现类。我们再来看下述代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ConcurrentHashMap&lt;String, String&gt; test = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">        Set&lt;String&gt; keySet = test.keySet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们用jdk8的javac来进行编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ /usr/lib/java8/bin/javac -source 1.7 -target 1.7 HelloWorld.java</div><div class="line">warning: [options] bootstrap class path not set in conjunction with -source 1.7</div><div class="line">1 warning</div></pre></td></tr></table></figure></p>
<p>或者中文版的报错信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">警告: [options] 未与 -source 1.7 一起设置引导类路径</div><div class="line">1 个警告</div></pre></td></tr></table></figure></p>
<p>但是上述代码是可以通过编译的，因为<code>KeySetView</code>是<code>Set</code>的实现类，所以1.7的语法没有任何问题。但是编译生成的class文件无法在1.7版本的jvm上运行。我们看一下字节码的实际内容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap.KeySetView;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></div><div class="line">  &#123;</div><div class="line">    ConcurrentHashMap localConcurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap();</div><div class="line">    ConcurrentHashMap.KeySetView localKeySetView = localConcurrentHashMap.keySet();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在字节码中，实际上<code>keySet</code>返回的是1.8中指定的<code>KeySetView</code>类，但是这个类在jdk1.7中是不存在的，所以当用1.7的jvm运行时，会抛出<code>NoSuchMethodError</code>的异常。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>为了解决这个问题，还是要看编译时的警告信息（不能忽视任何一个警告）。从warning的信息中我们可以得知，当指定了<code>-source</code>时，我们还需要一起指定引导类即bootstrap类，否则可能会出现某些兼容性的问题，比如刚才我们遇到的ConcurrentHashMap的问题。所以我们在编译的时候需要再加上引导类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /usr/lib/java8/bin/javac -source 1.7 -target 1.7 HelloWorld.java -bootclasspath /usr/lib/java7/jre/lib/rt.jar</div></pre></td></tr></table></figure></p>
<p>我们先来反编译生成的class文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></div><div class="line">  &#123;</div><div class="line">    ConcurrentHashMap localConcurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap();</div><div class="line">    Set localSet = localConcurrentHashMap.keySet();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到现在class文件中返回的类变为了Set，然后我们在用1.7的jvm来运行，发现一切正常，问题被解决了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以后在指定-source时，还需要同时指定-bootclasspath，否则就会默认使用当前javac所用到的jdk版本的核心jar包（比如rt.jar）。</p>
<h1 id="2017-08-11"><a href="#2017-08-11" class="headerlink" title="2017-08-11"></a>2017-08-11</h1><h2 id="Iterator和Enumeration"><a href="#Iterator和Enumeration" class="headerlink" title="Iterator和Enumeration"></a>Iterator和Enumeration</h2><p>Enumeration是一个接口，它的源码如下：</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Iterator也是一个接口，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><p>函数接口不同<br>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。<br>Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。</p>
</li>
<li><p>Iterator支持fail-fast机制，而Enumeration不支持。<br>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。<br>而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p>
</li>
</ol>
<h2 id="遍历速度比较"><a href="#遍历速度比较" class="headerlink" title="遍历速度比较"></a>遍历速度比较</h2><p>下面，我们编写一个Hashtable，然后分别通过 Iterator 和 Enumeration 去遍历它，比较它们的效率。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Enumeration;</div><div class="line"><span class="keyword">import</span> java.util.Hashtable;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorEnumeration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> val;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        Hashtable table = <span class="keyword">new</span> Hashtable();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000000</span>; i++) &#123;</div><div class="line">            <span class="comment">// 随机获取一个[0,100)之间的数字</span></div><div class="line">            val = r.nextInt(<span class="number">100</span>);</div><div class="line">            table.put(String.valueOf(i), val);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 通过Iterator遍历Hashtable</span></div><div class="line">        iterateHashtable(table) ;</div><div class="line"></div><div class="line">        <span class="comment">// 通过Enumeration遍历Hashtable</span></div><div class="line">        enumHashtable(table);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 通过Iterator遍历Hashtable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterateHashtable</span><span class="params">(Hashtable table)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        Iterator iter = table.entrySet().iterator();</div><div class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</div><div class="line">            <span class="comment">//System.out.println("iter:"+iter.next());</span></div><div class="line">            iter.next();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        countTime(startTime, endTime);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 通过Enumeration遍历Hashtable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumHashtable</span><span class="params">(Hashtable table)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        Enumeration enu = table.elements();</div><div class="line">        <span class="keyword">while</span>(enu.hasMoreElements()) &#123;</div><div class="line">            <span class="comment">//System.out.println("enu:"+enu.nextElement());</span></div><div class="line">            enu.nextElement();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</div><div class="line">        countTime(startTime, endTime);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countTime</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"time: "</span>+(end-start)+<span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>运行结果如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">time: 9ms</div><div class="line">time: 5ms</div></pre></td></tr></table></figure></p>
<p>从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？<br>这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。</p>
<hr>
<h1 id="2017-08-12"><a href="#2017-08-12" class="headerlink" title="2017-08-12"></a>2017-08-12</h1><h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文将从几个常用方法下手，来阅读HashMap的源码。<br>按照从构造方法-&gt;常用API（增、删、改、查）的顺序来阅读源码，并会讲解阅读方法中涉及的一些变量的意义。了解HashMap的特点、适用场景。</p>
<p>概括的说，HashMap 是一个关联数组、哈希表，它是线程不安全的，允许key为null,value为null。遍历时无序。<br>其底层数据结构是数组称之为哈希桶，每个桶里面放的是链表，链表中的每个节点，就是哈希表中的每个元素。<br>在JDK8中，当链表长度达到8，会转化成红黑树，以提升它的查询、插入效率，它实现了<code>Map&lt;K,V&gt;</code>, <code>Cloneable</code>, <code>Serializable</code>接口。</p>
<p>因其底层哈希桶的数据结构是数组，所以也会涉及到扩容的问题。</p>
<p>当HashMap的容量达到threshold域值时，就会触发扩容。扩容前后，哈希桶的长度一定会是2的次方。<br>这样在根据key的hash值寻找对应的哈希桶时，可以用位运算替代取余操作，更加高效。</p>
<p>而key的hash值，并不仅仅只是key对象的hashCode()方法的返回值，还会经过扰动函数的扰动，以使hash值更加均衡。<br>因为hashCode()是int类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。<br>但就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，发生不同的hash值，但是得到的index相同的情况的几率会大大增加，这种情况称之为hash碰撞。 即，碰撞率会增大。</p>
<p>扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）</p>
<p>扩容操作时，会new一个新的Node数组作为哈希桶，然后将原哈希表中的所有数据(Node节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个put操作。所以性能消耗很大，可想而知，在哈希表的容量越大时，性能消耗越明显。</p>
<p>扩容时，如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。<br>因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量<br>如果追加节点后，链表数量》=8，则转化为红黑树</p>
<p>由迭代器的实现可以看出，遍历HashMap时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于无序集合。</p>
<p>HashMap的源码中，充斥个各种位运算代替常规运算的地方，以提升效率： </p>
<ul>
<li>与运算替代模运算。用 <code>hash &amp; (table.length-1)</code> 替代 <code>hash % (table.length)</code></li>
<li>用<code>if ((e.hash &amp; oldCap) == 0)</code>判断扩容后，节点e处于低区还是高区。</li>
</ul>
<h3 id="链表节点Node"><a href="#链表节点Node" class="headerlink" title="链表节点Node"></a>链表节点Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//哈希值</span></div><div class="line">        <span class="keyword">final</span> K key;<span class="comment">//key</span></div><div class="line">        V value;<span class="comment">//value</span></div><div class="line">        Node&lt;K,V&gt; next;<span class="comment">//链表后置节点</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</div><div class="line"></div><div class="line">        <span class="comment">//每一个节点的hash值，是将key的hashCode 和 value的hashCode 异或运算得到的。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置新的value 同时返回旧value</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">            V oldValue = value;</div><div class="line">            value = newValue;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                    Objects.equals(value, e.getValue()))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>由此可知，这是一个单链表<br>每一个节点的hash值，是将key的hashCode和value的hashCode异或得到的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最大容量 2的30次方</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="comment">//默认的加载因子</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line"><span class="comment">//哈希桶，存放链表。 长度是2的N次方，或者初始化时为0.</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"><span class="comment">//加载因子，用于计算哈希表元素数量的阈值。  threshold = 哈希桶.length * loadFactor;</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div><div class="line"><span class="comment">//哈希表内元素数量的阈值，当哈希表内元素数量超过阈值时，会发生扩容resize()。</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//默认构造函数，赋值加载因子为默认的0.75f</span></div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">//指定初始化容量的构造函数</span></div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同时指定初始化容量 以及 加载因子， 用的很少，一般不会修改loadFactor</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="comment">//边界处理</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="comment">//初始容量最大不能超过2的30次方</span></div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="comment">//显然加载因子不能为负数</span></div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">//设置阈值为  》=初始化容量的 2的n次方的值</span></div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//新建一个哈希表，同时将另一个map m 里的所有元素加入表中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//根据期望容量cap，返回2的n次方形式的 哈希桶的实际容量 length。 返回值一般会&gt;=cap </span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line"><span class="comment">//经过下面的 或 和位移 运算， n最终各位都是1。</span></div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="comment">//判断n是否越界，返回 2的n次方作为 table（哈希桶）的阈值</span></div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">//将另一个Map的所有元素加入表中，参数evict初始化时为false，其他情况为true</span></div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    <span class="comment">//拿到m的元素数量</span></div><div class="line">    <span class="keyword">int</span> s = m.size();</div><div class="line">    <span class="comment">//如果数量大于0</span></div><div class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//如果当前表是空的</span></div><div class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></div><div class="line">            <span class="comment">//根据m的元素数量和当前表的加载因子，计算出阈值</span></div><div class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</div><div class="line">            <span class="comment">//修正阈值的边界 不能超过MAXIMUM_CAPACITY</span></div><div class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</div><div class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</div><div class="line">            <span class="comment">//如果新的阈值大于当前阈值</span></div><div class="line">            <span class="keyword">if</span> (t &gt; threshold)</div><div class="line">                <span class="comment">//返回一个 》=新的阈值的 满足2的n次方的阈值</span></div><div class="line">                threshold = tableSizeFor(t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果当前元素表不是空的，但是 m的元素数量大于阈值，说明一定要扩容。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</div><div class="line">            resize();</div><div class="line">        <span class="comment">//遍历 m 依次将元素加入当前表中。</span></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</div><div class="line">            K key = e.getKey();</div><div class="line">            V value = e.getValue();</div><div class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先看一下扩容函数： 这是一个重点！重点！重点！<br><strong> 初始化或加倍哈希桶大小。如果是当前哈希桶是null,分配符合当前阈值的初始容量目标。<br>否则，因为我们扩容成以前的两倍。<br>在扩容时，要注意区分以前在哈希桶相同index的节点，现在是在以前的index里，还是index+oldlength 里 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">        <span class="comment">//oldTab 为当前表的哈希桶</span></div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">        <span class="comment">//当前哈希桶的容量 length</span></div><div class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">        <span class="comment">//当前的阈值</span></div><div class="line">        <span class="keyword">int</span> oldThr = threshold;</div><div class="line">        <span class="comment">//初始化新的容量和阈值为0</span></div><div class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">        <span class="comment">//如果当前容量大于0</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//如果当前容量已经到达上限</span></div><div class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">                <span class="comment">//则设置阈值是2的31次方-1</span></div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line">                <span class="comment">//同时返回当前的哈希桶，不再扩容</span></div><div class="line">                <span class="keyword">return</span> oldTab;</div><div class="line">            &#125;<span class="comment">//否则新的容量为旧的容量的两倍。 </span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="comment">//如果旧的容量大于等于默认初始容量16</span></div><div class="line">                <span class="comment">//那么新的阈值也等于旧的阈值的两倍</span></div><div class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">        &#125;<span class="comment">//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">            newCap = oldThr;<span class="comment">//那么新表的容量就等于旧的阈值</span></div><div class="line">        <span class="keyword">else</span> &#123;&#125;<span class="comment">//如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况               // zero initial threshold signifies using defaults</span></div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//此时新表的容量为默认的容量 16</span></div><div class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//新的阈值为默认容量16 * 默认加载因子0.75f = 12</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况</span></div><div class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;<span class="comment">//根据新表容量 和 加载因子 求出新的阈值</span></div><div class="line">            <span class="comment">//进行越界修复</span></div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//更新阈值 </span></div><div class="line">        threshold = newThr;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        <span class="comment">//根据新的容量 构建新的哈希桶</span></div><div class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">        <span class="comment">//更新哈希桶引用</span></div><div class="line">        table = newTab;</div><div class="line">        <span class="comment">//如果以前的哈希桶中有元素</span></div><div class="line">        <span class="comment">//下面开始将当前哈希桶中的所有节点转移到新的哈希桶中</span></div><div class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//遍历老的哈希桶</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">                <span class="comment">//取出当前的节点 e</span></div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line">                <span class="comment">//如果当前桶中有元素,则将链表赋值给e</span></div><div class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//将原哈希桶置空以便GC</span></div><div class="line">                    oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                    <span class="comment">//如果当前链表中就一个元素，（没有发生哈希碰撞）</span></div><div class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                        <span class="comment">//直接将这个元素放置在新的哈希桶里。</span></div><div class="line">                        <span class="comment">//注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高</span></div><div class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                        <span class="comment">//如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树（暂且不谈 避免过于复杂， 后续专门研究一下红黑树）</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                    <span class="comment">//如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</span></div><div class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                        <span class="comment">//因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位=  low位+原哈希桶容量</span></div><div class="line">                        <span class="comment">//低位链表的头结点、尾节点</span></div><div class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                        <span class="comment">//高位链表的头节点、尾节点</span></div><div class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                        Node&lt;K,V&gt; next;<span class="comment">//临时节点 存放e的下一个节点</span></div><div class="line">                        <span class="keyword">do</span> &#123;</div><div class="line">                            next = e.next;</div><div class="line">                            <span class="comment">//这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位</span></div><div class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                                <span class="comment">//给头尾节点指针赋值</span></div><div class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                    loHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    loTail.next = e;</div><div class="line">                                loTail = e;</div><div class="line">                            &#125;<span class="comment">//高位也是相同的逻辑</span></div><div class="line">                            <span class="keyword">else</span> &#123;</div><div class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                    hiHead = e;</div><div class="line">                                <span class="keyword">else</span></div><div class="line">                                    hiTail.next = e;</div><div class="line">                                hiTail = e;</div><div class="line">                            &#125;<span class="comment">//循环直到链表结束</span></div><div class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//将低位链表存放在原index处，</span></div><div class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            loTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j] = loHead;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//将高位链表存放在新index处</span></div><div class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                            hiTail.next = <span class="keyword">null</span>;</div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newTab;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>再看一下 往哈希表里插入一个节点的putVal函数,如果参数onlyIfAbsent是true，那么不会覆盖相同key的值value。如果evict是false。那么表示是在初始化时调用的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    <span class="comment">//tab存放 当前的哈希桶， p用作临时链表节点  </span></div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">//如果当前哈希表是空的，代表是初始化</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        <span class="comment">//那么直接去扩容哈希表，并且将扩容后的哈希桶长度赋值给n</span></div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">//如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。</span></div><div class="line">    <span class="comment">//这里再啰嗦一下，index 是利用 哈希值 &amp; 哈希桶的长度-1，替代模运算</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;<span class="comment">//否则 发生了哈希冲突。</span></div><div class="line">        <span class="comment">//e</span></div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">//如果哈希值相等，key也相等，则是覆盖value操作</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;<span class="comment">//将当前节点引用赋值给e</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//红黑树暂且不谈</span></div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;<span class="comment">//不是覆盖操作，则插入一个普通链表节点</span></div><div class="line">            <span class="comment">//遍历链表</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//遍历到尾部，追加新节点到尾部</span></div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//如果追加节点后，链表数量》=8，则转化为红黑树</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果找到了要覆盖的节点</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果e不是null，说明有需要覆盖的节点，</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            <span class="comment">//则覆盖节点值，并返回原oldValue</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            <span class="comment">//这是一个空实现的函数，用作LinkedHashMap重写使用。</span></div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span></div><div class="line"></div><div class="line">    <span class="comment">//修改modCount</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">//更新size，并判断是否需要扩容。</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    <span class="comment">//这是一个空实现的函数，用作LinkedHashMap重写使用。</span></div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>newNode如下：构建一个链表节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create a regular (non-tree) node</span></div><div class="line">   <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="comment">//留给LinkedHashMap使用，当做链表的回调函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>小结： </p>
<ul>
<li>运算尽量都用位运算代替，更高效。 </li>
<li>对于扩容导致需要新建数组存放更多元素时，除了要将老数组中的元素迁移过来，也记得将老数组中的引用置null，以便GC </li>
<li>取下标 是用 哈希值 与运算 （桶的长度-1） i = (n - 1) &amp; hash。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高 </li>
<li>扩容时，如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。 </li>
<li>因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量 </li>
<li>利用哈希值 与运算 旧的容量 ，if ((e.hash &amp; oldCap) == 0),可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位。这里又是一个利用位运算 代替常规运算的高效点 </li>
<li>如果追加节点后，链表数量》=8，则转化为红黑树 </li>
<li>插入节点操作时，有一些空实现的函数，用作LinkedHashMap重写使用。</li>
</ul>
<h3 id="增、改"><a href="#增、改" class="headerlink" title="增、改"></a>增、改</h3><ol>
<li>往表中插入或覆盖一个key-value<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">//先根据key，取得hash值。 再调用上一节的方法插入节点</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个根据key取hash值的函数也要关注一下，它称之为“扰动函数”，关于这个函数的用处 开头已经总结过了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而key的hash值，并不仅仅只是key对象的hashCode()方法的返回值，还会经过扰动函数的扰动，以使hash值更加均衡。<br>因为hashCode()是int类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。<br>但就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，发生不同的hash值，但是得到的index相同的情况的几率会大大增加，这种情况称之为hash碰撞。 即，碰撞率会增大。<br>扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）</p>
<ol>
<li><p>往表中批量增加数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="comment">//这个函数上一节也已经分析过。//将另一个Map的所有元素加入表中，参数evict初始化时为false，其他情况为true</span></div><div class="line">    putMapEntries(m, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>只会往表中插入 key-value, 若key对应的value之前存在，不会覆盖。（jdk8增加的方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>以key为条件删除<br>如果key对应的value存在，则删除这个键值对。 并返回value。如果不存在 返回null。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从哈希表中删除某个节点， 如果参数matchValue是true，则必须key 、value都相等才删除。<br>如果movable参数是false，在删除节点时，不移动其他节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable) &#123;</div><div class="line">    <span class="comment">// p 是待删除节点的前置节点</span></div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">    <span class="comment">//如果哈希表不为空，则根据hash值算出的index下 有节点的话。</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//node是待删除节点</span></div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</div><div class="line">        <span class="comment">//如果链表头的就是需要删除的节点</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            node = p;<span class="comment">//将待删除节点引用赋给node</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;<span class="comment">//否则循环遍历 找到待删除节点，赋值给node</span></div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有待删除节点node，  且 matchValue为false，或者值也相等</span></div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//如果node ==  p，说明是链表头是待删除节点</span></div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="keyword">else</span><span class="comment">//否则待删除节点在表中间</span></div><div class="line">                p.next = node.next;</div><div class="line">            ++modCount;<span class="comment">//修改modCount</span></div><div class="line">            --size;<span class="comment">//修改size</span></div><div class="line">            afterNodeRemoval(node);<span class="comment">//LinkedHashMap回调函数</span></div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>留给LinkedHashMap回调的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>以key value 为条件删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</div><div class="line">    <span class="comment">//这里传入了value 同时matchValue为true</span></div><div class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>以key为条件，找到返回value。没找到返回null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="comment">//传入扰动后的哈希值 和 key 找到目标节点Node</span></div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"><span class="comment">//传入扰动后的哈希值 和 key 找到目标节点Node</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="comment">//查找过程和删除基本差不多， 找到返回节点，否则返回null</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断是否包含该key<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断是否包含value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; V v;</div><div class="line">    <span class="comment">//遍历哈希桶上的每一个链表</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</div><div class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                <span class="comment">//如果找到value一致的返回true</span></div><div class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</div><div class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>java8新增，带默认值的get方法<br>以key为条件，找到了返回value。否则返回defaultValue<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//缓存 entrySet</span></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EntrySet<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</div><div class="line">      <span class="comment">//一般我们用到EntrySet，都是为了获取iterator</span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//最终还是调用getNode方法</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">          Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class="line">          Object key = e.getKey();</div><div class="line">          Node&lt;K,V&gt; candidate = getNode(hash(key), key);</div><div class="line">          <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//最终还是调用removeNode方法</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div class="line">              Object key = e.getKey();</div><div class="line">              Object value = e.getValue();</div><div class="line">              <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//。。。</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>EntryIterator的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HashIterator<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</div><div class="line">       Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></div><div class="line">       Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></div><div class="line">       <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></div><div class="line">       <span class="keyword">int</span> index;             <span class="comment">// current slot</span></div><div class="line"></div><div class="line">       HashIterator() &#123;</div><div class="line">           <span class="comment">//因为hashmap也是线程不安全的，所以要保存modCount。用于fail-fast策略</span></div><div class="line">           expectedModCount = modCount;</div><div class="line">           Node&lt;K,V&gt;[] t = table;</div><div class="line">           current = next = <span class="keyword">null</span>;</div><div class="line">           index = <span class="number">0</span>;</div><div class="line">           <span class="comment">//next 初始时，指向 哈希桶上第一个不为null的链表头</span></div><div class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">               <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//由这个方法可以看出，遍历HashMap时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于无序集合。</span></div><div class="line">       <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">           Node&lt;K,V&gt;[] t;</div><div class="line">           Node&lt;K,V&gt; e = next;</div><div class="line">           <span class="comment">//fail-fast策略</span></div><div class="line">           <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">           <span class="comment">//依次取链表下一个节点，</span></div><div class="line">           <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="comment">//如果当前链表节点遍历完了，则取哈希桶下一个不为null的链表头</span></div><div class="line">               <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> e;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">           Node&lt;K,V&gt; p = current;</div><div class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">           <span class="comment">////fail-fast策略</span></div><div class="line">           <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">           current = <span class="keyword">null</span>;</div><div class="line">           K key = p.key;</div><div class="line">           <span class="comment">//最终还是利用removeNode 删除节点</span></div><div class="line">           removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div><div class="line">           expectedModCount = modCount;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="和HashTable相比"><a href="#和HashTable相比" class="headerlink" title="和HashTable相比"></a>和HashTable相比</h3><ul>
<li>与之相比HashTable是线程安全的，且不允许key、value是null。</li>
<li>HashTable默认容量是11。</li>
<li>HashTable是直接使用key的hashCode(key.hashCode())作为hash值，不像HashMap内部使用static final int hash(Object key)扰动函数对key的hashCode进行扰动后作为hash值。</li>
<li>HashTable取哈希桶下标是直接用模运算%.（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算）</li>
<li>扩容时，新容量是原来的2倍+1。int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</li>
<li>Hashtable是Dictionary的子类同时也实现了Map接口，HashMap是Map接口的一个实现类；<br>———<h1 id="2017-08-15"><a href="#2017-08-15" class="headerlink" title="2017-08-15"></a>2017-08-15</h1><h2 id="Runnable、Callable、Future、FutureTask的区别"><a href="#Runnable、Callable、Future、FutureTask的区别" class="headerlink" title="Runnable、Callable、Future、FutureTask的区别"></a>Runnable、Callable、Future、FutureTask的区别</h2><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3></li>
</ul>
<p>其中Runnable应该是我们最熟悉的接口，它只有一个run()函数，用于将耗时操作写在其中，该函数没有返回值。然后使用某个线程去执行该runnable即可实现多线程，Thread类在调用start()函数后就是执行的是Runnable的run()函数。Runnable的声明如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used </div><div class="line">     * to create a thread, starting the thread causes the object's </div><div class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing </div><div class="line">     * thread. </div><div class="line">     * &lt;p&gt; </div><div class="line">     * </div><div class="line">     * <span class="doctag">@see</span>     java.lang.Thread#run() </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>Callable与Runnable的功能大致相似，Callable中有一个call()函数，但是call()函数有返回值，而Runnable的run()函数不能将结果返回给客户程序。Callable的声明如下 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Computes a result, or throws an exception if unable to do so. </div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> computed result </div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result </div><div class="line">     */  </div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Executor就是Runnable和Callable的调度容器，Future就是对于具体的Runnable或者Callable任务的执行结果进行<br>取消、查询是否完成、获取结果、设置结果操作。get方法会阻塞，直到任务返回结果(Future简介)。Future声明如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">* <span class="doctag">@see</span> FutureTask </div><div class="line"> * <span class="doctag">@see</span> Executor </div><div class="line"> * <span class="doctag">@since</span> 1.5 </div><div class="line"> * <span class="doctag">@author</span> Doug Lea </div><div class="line"> * <span class="doctag">@param</span> &lt;V&gt; The result type returned by this Future's &lt;tt&gt;get&lt;/tt&gt; method </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Attempts to cancel execution of this task.  This attempt will </div><div class="line">     * fail if the task has already completed, has already been cancelled, </div><div class="line">     * or could not be cancelled for some other reason. If successful, </div><div class="line">     * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called, </div><div class="line">     * this task should never run.  If the task has already started, </div><div class="line">     * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines </div><div class="line">     * whether the thread executing this task should be interrupted in </div><div class="line">     * an attempt to stop the task.     * </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed </div><div class="line">     * normally. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this task completed. </div><div class="line">     * </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Waits if necessary for the computation to complete, and then </div><div class="line">     * retrieves its result. </div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> the computed result </div><div class="line">     */  </div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Waits if necessary for at most the given time for the computation </div><div class="line">     * to complete, and then retrieves its result, if available. </div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> timeout the maximum time to wait </div><div class="line">     * <span class="doctag">@param</span> unit the time unit of the timeout argument </div><div class="line">     * <span class="doctag">@return</span> the computed result </div><div class="line">     */  </div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  </span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask则是一个RunnableFuture<v>，而RunnableFuture实现了Runnbale又实现了Futrue<v>这两个接口，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;  </span></div><div class="line">### <span class="title">RunnableFuture</span></div><div class="line">```<span class="title">java</span></div><div class="line"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; &#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Sets this Future to the result of its computation </div><div class="line">     * unless it has been cancelled. </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></v></v></p>
<p>另外它还可以包装Runnable和Callable<v>， 由构造函数注入依赖。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">    <span class="keyword">this</span>.callable = callable;  </div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;  </div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);  </div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，Runnable注入会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务。该适配函数的实现如下 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RunnableAdapter适配器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * A callable that runs given task and returns given result </div><div class="line"> */  </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> Runnable task;  </div><div class="line">    <span class="keyword">final</span> T result;  </div><div class="line">    RunnableAdapter(Runnable task, T result) &#123;  </div><div class="line">        <span class="keyword">this</span>.task = task;  </div><div class="line">        <span class="keyword">this</span>.result = result;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;  </div><div class="line">        task.run();  </div><div class="line">        <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可以提交给ExecuteService来执行。<br>并且还可以直接通过get()函数获取执行结果，该函数会阻塞，直到结果返回。因此FutureTask既是Future、<br>Runnable，又是包装了(Callable如果是Runnable最终也会被转换为Callable )， 它是这两者的合体。</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">```java</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableFutureTask</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * ExecutorService </div><div class="line">     */  </div><div class="line">    <span class="keyword">static</span> ExecutorService mExecutor = Executors.newSingleThreadExecutor();</div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> args </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        runnableDemo();  </div><div class="line">        futureDemo();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * runnable, 无返回值 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runnableDemo</span><span class="params">()</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(fibc(<span class="number">20</span>))).start();</div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 其中Runnable实现的是void run()方法，无返回值；Callable实现的是 V </div><div class="line">     * call()方法，并且可以返回执行结果。其中Runnable可以提交给Thread来包装下 </div><div class="line">     * ，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureDemo</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="comment">/** </span></div><div class="line">             * 提交runnable则没有返回值, future没有数据 </div><div class="line">             */  </div><div class="line">            Future&lt;?&gt; result = mExecutor.submit(() -&gt; fibc(<span class="number">20</span>));</div><div class="line">  </div><div class="line">            System.out.println(<span class="string">"future result from runnable : "</span> + result.get());  </div><div class="line">  </div><div class="line">            <span class="comment">/** </span></div><div class="line">             * 提交Callable, 有返回值, future中能够获取返回值 </div><div class="line">             */  </div><div class="line">            Future&lt;Integer&gt; result2 = mExecutor.submit(() -&gt; fibc(<span class="number">20</span>));</div><div class="line">  </div><div class="line">            System.out  </div><div class="line">                    .println(<span class="string">"future result from callable : "</span> + result2.get());  </div><div class="line">  </div><div class="line">            <span class="comment">/** </span></div><div class="line">             * FutureTask则是一个RunnableFuture&lt;V&gt;，即实现了Runnbale又实现了Futrue&lt;V&gt;这两个接口， </div><div class="line">             * 另外它还可以包装Runnable(实际上会转换为Callable)和Callable </div><div class="line">             * &lt;V&gt;，所以一般来讲是一个符合体了，它可以通过Thread包装来直接执行，也可以提交给ExecuteService来执行 </div><div class="line">             * ，并且还可以通过v get()返回执行结果，在线程体没有执行完成的时候，主线程一直阻塞等待，执行完则直接返回结果。 </div><div class="line">             */  </div><div class="line">            FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; fibc(<span class="number">20</span>));</div><div class="line">            <span class="comment">// 提交futureTask  </span></div><div class="line">            mExecutor.submit(futureTask) ;  </div><div class="line">            System.out.println(<span class="string">"future result from futureTask : "</span>  </div><div class="line">                    + futureTask.get());  </div><div class="line">  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 效率底下的斐波那契数列, 耗时的操作 </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> num </div><div class="line">     * <span class="doctag">@return</span> </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> fibc(num - <span class="number">1</span>) + fibc(num - <span class="number">2</span>);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="2017-08-16"><a href="#2017-08-16" class="headerlink" title="2017-08-16"></a>2017-08-16</h1><h2 id="linux根目录下的文件详解"><a href="#linux根目录下的文件详解" class="headerlink" title="linux根目录下的文件详解"></a>linux根目录下的文件详解</h2><h3 id="linux哲学思想："><a href="#linux哲学思想：" class="headerlink" title="linux哲学思想："></a>linux哲学思想：</h3><blockquote>
<ol>
<li>一切皆文件；</li>
<li>体积小，目的单一的小程序组成；组合小程序，完成复杂的任务；</li>
<li>尽量避免捕获用户接口；</li>
<li>通过配置文件保存程序的配置信息，而配置文件通常是纯文本文件；</li>
</ol>
</blockquote>
<h3 id="根目录下的文件："><a href="#根目录下的文件：" class="headerlink" title="根目录下的文件："></a>根目录下的文件：</h3><ul>
<li><p><code>/boot</code> 该目录默认下存放的是Linux的启动文件和内核。</p>
</li>
<li><p><code>/initrd</code> 它的英文含义是boot loader initialized RAM disk,就是由boot loader初始化的内存盘。在linux<br>内核启动前，boot loader会将存储介质(一般是硬盘)中的initrd文件加载到内存，内核启动时会在访问真正的根文件系统前先访问该内存中的initrd文件系统。</p>
</li>
<li><p><code>/bin</code> 该目录中存放Linux的常用命令。</p>
</li>
<li><p><code>/sbin</code> 该目录用来存放系统管理员使用的管理程序。</p>
</li>
<li><p><code>/var</code> 该目录存放那些经常被修改的文件，包括各种日志、数据文件。</p>
</li>
<li><p><code>/etc</code> 该目录存放系统管理时要用到的各种配置文件和子目录，例如网络配置文件、文件系统、X系统配置文件、设备配置信息、设置用户信息等。</p>
</li>
<li><p><code>/dev</code> 该目录包含了Linux系统中使用的所有外部设备，它实际上是访问这些外部设备的端口，访问这些外部设备与访问一个文件或一个目录没有区别。</p>
</li>
<li><p><code>/mnt</code> 临时将别的文件系统挂在该目录下。</p>
</li>
<li><p><code>/root</code> 如果你是以超级用户的身份登录的，这个就是超级用户的主目录。</p>
</li>
<li><p><code>/home</code> 如果建立一个名为“xx”的用户，那么在/home目录下就有一个对应的“/home/xx”路径，用来存放该用户的主目录。</p>
</li>
<li><p><code>/usr</code> 用户的应用程序和文件几乎都存放在该目录下。</p>
</li>
<li><p><code>/lib</code> 该目录用来存放系统动态链接共享库，几乎所有的应用程序都会用到该目录下的共享库。</p>
</li>
<li><p><code>/opt</code> 第三方软件在安装时默认会找这个目录,所以你没有安装此类软件时它是空的,但如果你一旦把它删除了,以后在安装此类软件时就有可能碰到麻烦。</p>
</li>
<li><p><code>/tmp</code> 用来存放不同程序执行时产生的临时文件，该目录会被系统自动清理干净。</p>
</li>
<li><p><code>/proc</code> 可以在该目录下获取系统信息，这些信息是在内存中由系统自己产生的，该目录的内容不在硬盘上而在内存里。</p>
</li>
<li><p><code>/misc</code> 可以让多用户堆积和临时转移自己的文件。</p>
</li>
<li><p><code>/lost＋found</code> 该目录在大多数情况下都是空的。但当突然停电、或者非正常关机后，有些文件就临时存放在这里。</p>
</li>
</ul>
<hr>
<h1 id="2017-08-18"><a href="#2017-08-18" class="headerlink" title="2017-08-18"></a>2017-08-18</h1><h2 id="线程池ThreadPoolExecutor解析"><a href="#线程池ThreadPoolExecutor解析" class="headerlink" title="线程池ThreadPoolExecutor解析"></a>线程池ThreadPoolExecutor解析</h2><p>JDK1.5中引入了强大的concurrent包，其中最常用的莫过了线程池的实现ThreadPoolExecutor，它给我们带来了极大的方便，但同时，对于该线程池不恰当的设置也可能使其效率并不能达到预期的效果，甚至仅相当于或低于单线程的效率。<br>线程池的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                         <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                         <span class="keyword">long</span> keepAliveTime,</div><div class="line">                         TimeUnit unit,</div><div class="line">                         BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                         ThreadFactory threadFactory,</div><div class="line">                         RejectedExecutionHandler handler) &#123;</div><div class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">            maximumPoolSize &lt; corePoolSize ||</div><div class="line">            keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">        <span class="keyword">this</span>.handler = handler;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="ThreadPoolExecutor类可设置的参数主要有："><a href="#ThreadPoolExecutor类可设置的参数主要有：" class="headerlink" title="ThreadPoolExecutor类可设置的参数主要有："></a>ThreadPoolExecutor类可设置的参数主要有：</h2><ol>
<li>corePoolSize 核心线程数</li>
</ol>
<ul>
<li>核心线程会一直存活，即使没有任务需要处理。</li>
<li>当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。</li>
<li>核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。</li>
</ul>
<ol>
<li>maxPoolSize 最大线程数</li>
</ol>
<ul>
<li>当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。</li>
<li>如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。</li>
</ul>
<ol>
<li>keepAliveTime 线程空闲时间</li>
</ol>
<ul>
<li>当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。</li>
<li>如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。</li>
</ul>
<ol>
<li>allowCoreThreadTimeout 允许核心线程超时</li>
</ol>
<ul>
<li>是否允许核心线程空闲退出，默认值为false</li>
</ul>
<ol>
<li>queueCapacity 任务队列容量</li>
</ol>
<ul>
<li>当核心线程数达到最大时，新任务会放在队列中排队等待执行</li>
</ul>
<ol>
<li>rejectedExecutionHandler：任务拒绝处理器 </li>
</ol>
<ul>
<li><p>两种情况会拒绝处理任务：</p>
<ul>
<li>当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务 </li>
<li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务 </li>
</ul>
</li>
<li><p>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常 </p>
</li>
<li>ThreadPoolExecutor类有几个内部实现类来处理这类情况：<ul>
<li>AbortPolicy 丢弃任务，抛运行时异常 </li>
<li>CallerRunsPolicy 执行任务 </li>
<li>DiscardPolicy 忽视，什么都不会发生</li>
<li>DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务,如果使用的任务队列是优先队列PriorityBlockingQueue，那么抛弃权重最高的任务</li>
</ul>
</li>
<li>实现RejectedExecutionHandler接口，可自定义处理器</li>
</ul>
<h2 id="如何执行任务"><a href="#如何执行任务" class="headerlink" title="如何执行任务"></a>如何执行任务</h2><p><strong>线程池按以下行为执行任务：</strong></p>
<ol>
<li>当线程数小于核心线程数时，创建线程。</li>
<li>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。</li>
<li>当线程数大于等于核心线程数，且任务队列已满<ol>
<li>若线程数小于最大线程数，创建线程</li>
<li>若线程数等于最大线程数，抛出异常，拒绝任务</li>
</ol>
</li>
</ol>
<h2 id="如何设置参数"><a href="#如何设置参数" class="headerlink" title="如何设置参数"></a>如何设置参数</h2><p><strong>默认值：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">corePoolSize=1 </div><div class="line">queueCapacity=Integer.MAX_VALUE </div><div class="line">maxPoolSize=Integer.MAX_VALUE </div><div class="line">keepAliveTime=60s </div><div class="line">allowCoreThreadTimeout=false </div><div class="line">rejectedExecutionHandler=AbortPolicy()</div></pre></td></tr></table></figure></p>
<p>需要根据几个值来决定</p>
<ul>
<li>tasks ：每秒的任务数，假设为500~1000 </li>
<li>taskcost：每个任务花费时间，假设为0.1s </li>
<li>responsetime：系统允许容忍的最大响应时间，假设为1s<br>做几个计算 </li>
<li>corePoolSize = 每秒需要多少个线程处理？ <ul>
<li>threadcount = tasks / (1 / taskcost) = tasks</li>
<li>taskcout = (500~1000) * 0.1 = 50~100 个线程。corePoolSize设置应该大于50</li>
<li>根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可 </li>
</ul>
</li>
<li>queueCapacity = (coreSizePool/taskcost) * responsetime <ul>
<li>计算可得 queueCapacity = 80 / 0.1 * 1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行 </li>
<li>切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。 </li>
</ul>
</li>
<li>maxPoolSize = (max(tasks)- queueCapacity) / (1 / taskcost) <ul>
<li>计算可得 maxPoolSize = (1000 - 80) / 10 = 92 * （最大任务数-队列容量）/ 每个线程每秒处理能力 = 最大线程数</li>
</ul>
</li>
<li>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</li>
<li>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足</li>
</ul>
<p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p>
<p>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。<br>任务的优先级：高，中和低。<br>任务的执行时间：长，中和短。<br>任务的依赖性：是否依赖其他系统资源，如数据库连接。<br>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<p>建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。<br>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void beforeExecute(Thread t, Runnable r) &#123; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="2017-08-19"><a href="#2017-08-19" class="headerlink" title="2017-08-19"></a>2017-08-19</h1><h2 id="Linux后台运行jar文件"><a href="#Linux后台运行jar文件" class="headerlink" title="Linux后台运行jar文件"></a>Linux后台运行jar文件</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar XXX.jar</div></pre></td></tr></table></figure>
<p>特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出<br>那如何让窗口不锁定？</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar XXX.jar &amp;</div></pre></td></tr></table></figure>
<p>&amp;代表在后台运行。<br>特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。<br>继续改进，如何让窗口关闭时，程序仍然运行？</p>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup java -jar XXX.jar &amp;</div></pre></td></tr></table></figure>
<p>nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行<br>当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。</p>
<h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup java -jar XXX.jar &gt;result.log 2&gt;error.log &amp;</div></pre></td></tr></table></figure>
<p>command &gt;out.file<br>command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中<br>这里我们将结果输出重定向到result.log中<br>2 &gt; out.file是指将错误的输出重定向到文件，我们将错误的输出重定向到error.log</p>
<h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><p>可通过jobs命令查看后台运行任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jobs</div></pre></td></tr></table></figure></p>
<p>那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。<br>如果想将某个作业调回前台控制，只需要 fg + 编号即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fg 23</div></pre></td></tr></table></figure></p>
<p>__</p>
<h1 id="2017-08-23"><a href="#2017-08-23" class="headerlink" title="2017-08-23"></a>2017-08-23</h1><h2 id="内部类为什么可以访问外部类的属性"><a href="#内部类为什么可以访问外部类的属性" class="headerlink" title="内部类为什么可以访问外部类的属性"></a>内部类为什么可以访问外部类的属性</h2><h3 id="内部类定义"><a href="#内部类定义" class="headerlink" title="内部类定义"></a>内部类定义</h3><p>内部类就是定义在一个类内部的类。定义在类内部的类有两种情况：一种是被static关键字修饰的， 叫做静态内部类， 另一种是不被static关键字修饰的， 就是普通内部类。 在下文中所提到的内部类都是指这种不被static关键字修饰的普通内部类。 静态内部类虽然也定义在外部类的里面， 但是它只是在形式上（写法上）和外部类有关系， 其实在逻辑上和外部类并没有直接的关系。而一般的内部类，不仅在形式上和外部类有关系（写在外部类的里面）， 在逻辑上也和外部类有联系。 这种逻辑上的关系可以总结为以下两点：</p>
<ol>
<li>内部类对象的创建依赖于外部类对象；</li>
<li>内部类对象持有指向外部类对象的引用。</li>
</ol>
<p>上边的第二条可以解释为什么在内部类中可以访问外部类的成员。就是因为内部类对象持有外部类对象的引用。但是我们不禁要问， 为什么会持有这个引用？<br>在源代码层面， 我们无法看到原因，因为Java为了语法的简介， 省略了很多该写的东西， 也就是说很多东西本来应该在源代码中写出， 但是为了简介起见， 不必在源码中写出，编译器在编译时会加上一些代码。 现在我们就看看Java的编译器为我们加上了什么？<br>首先建一个工程TestInnerClass用于测试。 在该工程中为了简单起见， 没有创建包， 所以源代码直接在默认包中。在该工程中， 只有下面一个简单的文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> outerField = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> i = outerField;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后产生两个class文件，分别是<code>Outer$Inner.class</code>和<code>Outer.class</code>，这里我们看起来内部类除了前面有个外部类的名字之外，和其他类并没有区别，别的类和外部类也是两个不同的class文件，为什么内部类就可以访问呢？我们这样想，java总归还是java，再怎么变也不会超过这个语言的特性，能访问这个类说明，肯定是内部类持有一个引用，指向了外部类，编译器应该是帮我们做了这些事，我们不知道而已。</p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>这里我们的目的是探究内部类的行为， 所以只反编译内部类的class文件Outer$Inner.class 。 在命令行中， 切换到工程的bin目录， 输入以下命令反编译这个类文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -classpath . -v Outer$Inner</div></pre></td></tr></table></figure></p>
<p>-classpath . 说明在当前目录下寻找要反编译的class文件 -v 加上这个参数输出的信息比较全面。包括常量池和方法内的局部变量表， 行号， 访问标志等等。<br>注意， 如果有包名的话， 要写class文件的全限定名， 如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -classpath . -v com.baidu.Outer$Inner</div></pre></td></tr></table></figure></p>
<p>反编译的输出结果很多， 为了篇幅考虑， 在这里我们省略了常量池。 下面给出除了常量池之外的输出信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  final Outer this$0;</div><div class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</div><div class="line"> </div><div class="line"> </div><div class="line">  Outer$Inner(Outer);</div><div class="line">    flags:</div><div class="line">    Code:</div><div class="line">      stack=2, locals=2, args_size=2</div><div class="line">         0: aload_0</div><div class="line">         1: aload_1</div><div class="line">         2: putfield      #10                 // Field this$0:LOuter;</div><div class="line">         5: aload_0</div><div class="line">         6: invokespecial #12                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">         9: return</div><div class="line">      LineNumberTable:</div><div class="line">        line 5: 0</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">               0      10     0  this   LOuter$Inner;</div><div class="line"> </div><div class="line">  void InnerMethod();</div><div class="line">    flags:</div><div class="line">    Code:</div><div class="line">      stack=1, locals=2, args_size=1</div><div class="line">         0: aload_0</div><div class="line">         1: getfield      #10                 // Field this$0:LOuter;</div><div class="line">         4: getfield      #20                 // Field Outer.outerField:I</div><div class="line">         7: istore_1</div><div class="line">         8: return</div><div class="line">      LineNumberTable:</div><div class="line">        line 7: 0</div><div class="line">        line 8: 8</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">               0       9     0  this   LOuter$Inner;</div><div class="line">               8       1     1     i   I</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们会看到， 第一行的信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final Outer this$0;</div></pre></td></tr></table></figure></p>
<p>这句话的意思是， 在内部类Outer$Inner中， 存在一个名字为this$0 ， 类型为Outer的成员变量， 并且这个变量是final的。 其实这个就是所谓的“在内部类对象中存在的指向外部类对象的引用”。但是我们在定义这个内部类的时候， 并没有声明它， 所以这个成员变量是编译器加上的。<br>虽然编译器在创建内部类时为它加上了一个指向外部类的引用， 但是这个引用是怎样赋值的呢？毕竟必须先给他赋值，　它才能指向外部类对象。　下面我们把注意力转移到构造函数上。 下面这段输出是关于构造函数的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Outer$Inner(Outer);  </div><div class="line">  flags:  </div><div class="line">  Code:  </div><div class="line">    stack=2, locals=2, args_size=2  </div><div class="line">       0: aload_0  </div><div class="line">       1: aload_1  </div><div class="line">       2: putfield      #10                 // Field this$0:LOuter;  </div><div class="line">       5: aload_0  </div><div class="line">       6: invokespecial #12                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V  </div><div class="line">       9: return  </div><div class="line">    LineNumberTable:  </div><div class="line">      line 5: 0  </div><div class="line">    LocalVariableTable:  </div><div class="line">      Start  Length  Slot  Name   Signature  </div><div class="line">             0      10     0  this   LOuter$Inner;</div></pre></td></tr></table></figure></p>
<p>我们知道， 如果在一个类中， 不声明构造方法的话， 编译器会默认添加一个无参数的构造方法。 但是这句话在这里就行不通了， 因为我们明明看到， 这个构造函数有一个构造方法， 并且类型为Outer。 所以说，<strong>编译器会为内部类的构造方法添加一个参数， 参数的类型就是外部类的类型。</strong><br>下面我们看看在构造参数中如何使用这个默认添加的参数。 我们来分析一下构造方法的字节码。 下面是每行字节码的意义：</p>
<p>aload_0 ：<br> 将局部变量表中的第一个引用变量加载到操作数栈。 这里有几点需要说明。 局部变量表中的变量在方法执行前就已经初始化完成；局部变量表中的变量包括方法的参数；成员方法的局部变量表中的第一个变量永远是this；操作数栈就是执行当前代码的栈。所以这句话的意思是： 将this引用从局部变量表加载到操作数栈。</p>
<p>aload_1：<br>将局部变量表中的第二个引用变量加载到操作数栈。 这里加载的变量就是构造方法中的Outer类型的参数。</p>
<p>putfield      #10                 // Field this$0:LOuter;<br>使用操作数栈顶端的引用变量为指定的成员变量赋值。 这里的意思是将外面传入的Outer类型的参数赋给成员变量this$0 。<br>这一句putfield字节码就揭示了， 指向外部类对象的这个引用变量是如何赋值的。<br>下面几句字节码和本文讨论的话题无关， 只做简单的介绍。 下面几句字节码的含义是： 使用this引用调用父类（Object）的构造方法然后返回。</p>
<p>用我们比较熟悉的形式翻译过来， 这个内部类和它的构造函数有点像这样： （注意， 这里不符合Java的语法， 只是为了说明问题）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Inner</span></span>&#123;  </div><div class="line">    <span class="keyword">final</span> Outer <span class="keyword">this</span>$<span class="number">0</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">public</span> Outer$Inner(Outer outer)&#123;  </div><div class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = outer;  </div><div class="line">        <span class="keyword">super</span>();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于在内部类中如何使用指向外部类的引用访问外部类成员， 就不用多做解释了， 其实和普通的通过引用访问成员的方式是相同的。 在内部类的InnerMethod方法中， 访问了外部类的成员变量outerField， 下面的字节码揭示了访问是如何进行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void InnerMethod();  </div><div class="line">  flags:  </div><div class="line">  Code:  </div><div class="line">    stack=1, locals=2, args_size=1  </div><div class="line">       0: aload_0  </div><div class="line">       1: getfield      #10                 // Field this$0:LOuter;  </div><div class="line">       4: getfield      #20                 // Field Outer.outerField:I  </div><div class="line">       7: istore_1  </div><div class="line">       8: return</div></pre></td></tr></table></figure></p>
<p>getfield      #10                 // Field this$0:LOuter;<br>将成员变量this$0加载到操作数栈上来</p>
<p>getfield      #20                 // Field Outer.outerField:I<br>使用上面加载的this$0引用， 将外部类的成员变量outerField加载到操作数栈</p>
<p>istore_1<br>将操作数栈顶端的int类型的值保存到局部变量表中的第二个变量上（注意， 第一个局部变量被this占用， 第二个局部变量是i）。操作数栈顶端的int型变量就是上一步加载的outerField变量。 所以， 这句字节码的含义就是： 使用outerField为i赋值。</p>
<p>上面三步就是内部类中是如何通过指向外部类对象的引用， 来访问外部类成员的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过反编译内部类的字节码， 说明了内部类是如何访问外部类对象的成员的，除此之外， 我们也对编译器的行为有了一些了解， 编译器在编译时会自动加上一些逻辑， 这正是我们感觉困惑的原因。 </p>
<p>关于内部类如何访问外部类的成员， 分析之后其实也很简单， 主要是通过以下几步做到的：</p>
<ol>
<li>编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用；</li>
<li>编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；</li>
<li>在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。</li>
</ol>
<p>其实内部类可以访问类这个细节我们都知道，可是为什么呢？这就需要我们有思考问题的能力，深入探究细节，知其然和知其所以然，思维方式需要转变，深入的去考虑问题，不要只停留在表面，这也是自己需要提升的地方。</p>
<hr>
<h1 id="2017-08-29"><a href="#2017-08-29" class="headerlink" title="2017-08-29"></a>2017-08-29</h1><h2 id="字节数组转16进制字符串"><a href="#字节数组转16进制字符串" class="headerlink" title="字节数组转16进制字符串"></a>字节数组转16进制字符串</h2><p>对每一个字节，先和0xFF做与运算，然后使用Integer.toHexString()函数，如果结果只有1位，需要在前面加0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  * 字节数组转16进制字符串</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2HexString</span><span class="params">(<span class="keyword">byte</span>[] b)</span> </span>&#123;</div><div class="line">     String r = <span class="string">""</span>;</div><div class="line">     </div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</div><div class="line">         String hex = Integer.toHexString(b[i] &amp; <span class="number">0xFF</span>);</div><div class="line">         <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</div><div class="line">             hex = <span class="string">'0'</span> + hex;</div><div class="line">         &#125;</div><div class="line">         r += hex.toUpperCase();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">return</span> r;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="2017-08-31"><a href="#2017-08-31" class="headerlink" title="2017-08-31"></a>2017-08-31</h1><h2 id="crontab-定时任务"><a href="#crontab-定时任务" class="headerlink" title="crontab 定时任务"></a>crontab 定时任务</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>简而言之呢，crontab就是一个自定义定时器。<br>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul>
<li>其一：<code>/var/spool/cron/</code><br>该目录下存放的是每个用户（包括root）的crontab任务，文件名以用户名命名</li>
<li>其二：<code>/etc/cron.d/</code><br>这个目录用来存放任何要执行的crontab文件或脚本。</li>
</ul>
<h3 id="crontab时间说明"><a href="#crontab时间说明" class="headerlink" title="crontab时间说明"></a>crontab时间说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># .---------------- minute (0 - 59) </div><div class="line"># |  .------------- hour (0 - 23)</div><div class="line"># |  |  .---------- day of month (1 - 31)</div><div class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... </div><div class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7)  OR</div><div class="line">#sun,mon,tue,wed,thu,fri,sat </div><div class="line"># |  |  |  |  |</div><div class="line"># *  *  *  *  *  command to be executed</div></pre></td></tr></table></figure>
<ul>
<li>minute：代表一小时内的第几分，范围 0-59。</li>
<li>hour：代表一天中的第几小时，范围 0-23。</li>
<li>mday：代表一个月中的第几天，范围 1-31。</li>
<li>month：代表一年中第几个月，范围 1-12。</li>
<li>wday：代表星期几，范围 0-7 (0及7都是星期天)。</li>
<li>who：要使用什么身份执行该指令，当您使用 crontab -e 时，不必加此字段。</li>
<li>command：所要执行的指令。</li>
</ul>
<h3 id="crontab服务状态"><a href="#crontab服务状态" class="headerlink" title="crontab服务状态"></a>crontab服务状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo service crond start     #启动服务</div><div class="line">sudo service crond stop      #关闭服务</div><div class="line">sudo service crond restart   #重启服务</div><div class="line">sudo service crond reload    #重新载入配置</div><div class="line">sudo service crond status    #查看服务状态</div></pre></td></tr></table></figure>
<h3 id="crontab命令"><a href="#crontab命令" class="headerlink" title="crontab命令"></a>crontab命令</h3><p>查看crontab定时任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab -l</div></pre></td></tr></table></figure></p>
<p>编辑定时任务【删除-添加-修改】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab -e</div></pre></td></tr></table></figure></p>
<p>添加定时任务【推荐】<br>Step-One : 编辑任务脚本【分目录存放】【ex: backup.sh】<br>Step-Two : 编辑定时文件【命名规则:backup.cron】<br>Step-Three : crontab命令添加到系统crontab backup.cron<br>Step-Four : 查看crontab列表 crontab -l</p>
<h3 id="crontab时间举例"><a href="#crontab时间举例" class="headerlink" title="crontab时间举例"></a>crontab时间举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"># 每天早上6点 </div><div class="line">0 6 * * * echo &quot;Good morning.&quot; &gt;&gt; /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。</div><div class="line"></div><div class="line"># 每两个小时 </div><div class="line">0 */2 * * * echo &quot;Have a break now.&quot; &gt;&gt; /tmp/test.txt  </div><div class="line"></div><div class="line"># 晚上11点到早上8点之间每两个小时和早上八点 </div><div class="line">0 23-7/2，8 * * * echo &quot;Have a good dream&quot; &gt;&gt; /tmp/test.txt</div><div class="line"></div><div class="line"># 每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 </div><div class="line">0 11 4 * 1-3 command line</div><div class="line"></div><div class="line"># 1月1日早上4点 </div><div class="line">0 4 1 1 * command line SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root //如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ </div><div class="line"></div><div class="line"># 每小时（第一分钟）执行/etc/cron.hourly内的脚本</div><div class="line">01 * * * * root run-parts /etc/cron.hourly</div><div class="line"></div><div class="line"># 每天（凌晨4：02）执行/etc/cron.daily内的脚本</div><div class="line">02 4 * * * root run-parts /etc/cron.daily </div><div class="line"></div><div class="line"># 每星期（周日凌晨4：22）执行/etc/cron.weekly内的脚本</div><div class="line">22 4 * * 0 root run-parts /etc/cron.weekly </div><div class="line"></div><div class="line"># 每月（1号凌晨4：42）去执行/etc/cron.monthly内的脚本 </div><div class="line">42 4 1 * * root run-parts /etc/cron.monthly </div><div class="line"></div><div class="line"># 注意:  &quot;run-parts&quot;这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。 　 </div><div class="line"></div><div class="line"># 每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。 </div><div class="line">5，15，25，35，45，55 16，17，18 * * * command</div><div class="line"></div><div class="line"># 每周一，三，五的下午3：00系统进入维护状态，重新启动系统。</div><div class="line">00 15 * *1，3，5 shutdown -r +5</div><div class="line"></div><div class="line"># 每小时的10分，40分执行用户目录下的innd/bbslin这个指令： </div><div class="line">10，40 * * * * innd/bbslink </div><div class="line"></div><div class="line"># 每小时的1分执行用户目录下的bin/account这个指令： </div><div class="line">1 * * * * bin/account</div><div class="line"></div><div class="line"># 每天早晨三点二十分执行用户目录下如下所示的两个指令（每个指令以;分隔）： </div><div class="line">203 * * * （/bin/rm -f expire.ls logins.bad;bin/expire$#@62;expire.1st）</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录个人在2017年08月的学习和总结，不定期更新&lt;br&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://zgj12138.github.io/blog/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>hadoop初探</title>
    <link href="https://zgj12138.github.io/blog/2017/07/30/hadoop%E5%88%9D%E6%8E%A2/"/>
    <id>https://zgj12138.github.io/blog/2017/07/30/hadoop初探/</id>
    <published>2017-07-30T15:42:08.000Z</published>
    <updated>2017-08-08T16:04:17.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近几年，大数据，云计算，机器学习成为了非常热门的话题，这些技术运用在了很多的领域，也是在未来很有发展前景的技术。自己最近在接触一些大数据的东西，学习大数据的话自然很有必要先学习Hadoop和Spark。这里我们就来一探Hadoop的究竟吧。<br><img src="https://i.loli.net/2017/07/29/597c475fd58d4.png" alt="hadoop-pic1.png"><br><a id="more"></a></p>
<h1 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h1><p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。<br>用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。<br>Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。<br>核心设计：</p>
<ol>
<li><code>HDFS</code>: HDFS为海量的数据提供了存储</li>
<li><code>MapReduce</code>: MapReduce为海量的数据提供了计算</li>
</ol>
<p>Hadoop的作者是Doug Cutting，他受到谷歌的三篇论文的启发GFS(分布式存储系统)，MapReduce(分布式运行模型), BigTable(大表)，然后用Java去实现了这三个功能，然后就有了Hadoop，不得不感叹，牛人真的是牛人啊</p>
<p>Hadoop是专为离线和大规模数据分析而设计的，并不适合那种对几个记录随机读写的在线事务处理模式,数据来源可以来自任何的形式，无论数据采用什么形式，最终都会转换成<code>key-value</code>的形式，<code>key/value</code>是基本数据单元<br>简单总结来说，Hadoop是一种分布式计算的解决方案</p>
<h1 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h1><p>Hadoop就是解决了大数据（大到一台计算机无法进行存储，一台计算机无法在要求的时间内进行处理）的可靠存储和处理的问题。<br>也就是两个核心的设计，HDFS和MapReduce</p>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><h3 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h3><p>1、大数据文件，非常适合上T级别的大文件或者一堆大数据文件的存储，现在互联网上的数据量非常庞大，动不动上T的数据，所以非常适合Hadoop。<br>2、文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算器上，它的意义在于读取文件时可以同时从多个主机取不同区块的文件，多主机读取比单主机读取效率要高得多。<br>3、流式数据访问，一次写入多次读写，这种模式跟传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化也只能在文件末添加内容。<br>4、廉价硬件，HDFS可以应用在普通PC机上，这种机制能够让给一些公司用几十台廉价的计算机就可以撑起一个大数据集群。<br>5、硬件故障，HDFS认为所有计算机都可能会出问题，为了防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其它某几个主机上，如果其中一台主机失效，可以迅速找另一块副本取文件。</p>
<h3 id="关键元素"><a href="#关键元素" class="headerlink" title="关键元素"></a>关键元素</h3><ol>
<li>Block：将一个文件进行分块，通常是128M。</li>
<li>NameNode：保存整个文件系统的目录信息、文件信息及分块信息，这是由唯一一台主机专门保存，当然这台主机如果出错，NameNode就失效了。在Hadoop2.*开始支持activity-standy模式—-如果主NameNode失效，启动备用主机运行NameNode。</li>
<li>DataNode：分布在廉价的计算机上，用于存储Block块文件。</li>
</ol>
<p><img src="https://i.loli.net/2017/07/29/597c99a70523f.gif" alt="hdfs.gif"></p>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce是一套从海量源数据提取分析元素最后返回结果集的编程模型，将文件分布式存储到硬盘是第一步，而从海量数据中提取分析我们需要的内容就是MapReduce做的事了。</p>
<p>举个例子吧，假如说你想统计一个巨大的文本文件存储在HDFS上，你想要知道这个文本里各个词的出现频率。我们把我们要运算的逻辑分发到各个节点上，在每个节点上进行运算和统计，假如在各个节点上对这些单词进行统计，我们输入的格式是一行一行的文本，而统计的结果像key-value的形式，比如在第一个节点上(hello, 30), (world, 22), (hadoop, 60),第二个节点上(hello, 20), (world, 32), (spark, 70)，也就是说将任何形式的数据转换成key-value的形式，这个过程就是Map。<br>然后我们要统计整个文本的单词出现的次数，就要对这些节点上的数据进行汇总，将这些节点上的数据按照key分组，合并，也就是(a, num1),(a, num2), (b, num3),(b, num4(合并后就变成(a, num1 + num2), (b, num3 + num4),按照上面的结果合并就是<br>(hello, 50), (world, 54), (hadoop, 60), spark(70)，这个过程就是Reduce<br><img src="https://i.loli.net/2017/07/29/597c53e72ab12.jpg" alt="mapreduce.jpg"></p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>hadoop擅长离线日志分析，facebook就用Hive来进行日志分析，2009年时facebook就有非编程人员的30%的人使用HiveQL进行数据分析；淘宝搜索中的自定义筛选也使用的Hive；利用Pig还可以做高级的数据处理，包括Twitter、LinkedIn上用于发现您可能认识的人，可以实现类似Amazon.com的协同过滤的推荐效果。淘宝的商品推荐也是！在Yahoo！的40%的Hadoop作业是用pig运行的，包括垃圾邮件的识别和过滤，还有用户特征建模。（2012年8月25新更新，天猫的推荐系统是hive，少量尝试mahout！）<br>不过从现在企业的使用趋势来看,Pig慢慢有点从企业的视野中淡化了。</p>
<h1 id="Hadoop伪分布式的安装"><a href="#Hadoop伪分布式的安装" class="headerlink" title="Hadoop伪分布式的安装"></a>Hadoop伪分布式的安装</h1><p>好了，我们了解和学习了Hadoop的概念之后就来学习一下如何安装Hadoop吧，这里我们先来学习伪分布式的安装，也就是NameNode和DataNoe都在同一台服务器上而且salve也是自己</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>虚拟机Vmware</li>
<li>Centos 6.9</li>
<li>Hadoop 2.7.3</li>
<li>JDK 1.8</li>
</ol>
<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>我们首先先安装好Centos，然后配置好网络，虚拟机与主机的连接方式选择NAT,然后cmd命令输入ipconfig<br>，记录下VMware Network Adapter VMnet8 下的IP,在虚拟机中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</div></pre></td></tr></table></figure></p>
<p>IP地址要和VMware Network Adapter VMnet8 下的IP在同一个网段,我的IP是192.168.109.1，贴一个自己的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DEVICE=eth0</div><div class="line">TYPE=Ethernet</div><div class="line">ONBOOT=yes</div><div class="line">NM_CONTROLLED=yes</div><div class="line">BOOTPROTO=static</div><div class="line">IPADDR=192.168.109.3</div><div class="line">NETMASK=255.255.255.0</div><div class="line">GATEWAY=192.168.109.2</div><div class="line">DNS1=192.168.109.2</div></pre></td></tr></table></figure></p>
<p>然后使用命令<code>service network restart</code>重启网络</p>
<h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysconfig/network</div></pre></td></tr></table></figure>
<p>NETWORKING=yes<br>HOSTNAME=hadoop1</p>
<h3 id="修改主机名和IP的映射关系"><a href="#修改主机名和IP的映射关系" class="headerlink" title="修改主机名和IP的映射关系"></a>修改主机名和IP的映射关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/hosts</div></pre></td></tr></table></figure>
<p>192.168.109.3    hadoop1</p>
<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>这里我们需要关闭我们的防火墙，开启防火墙会有访问限制，在虚拟机局域网内我们也不需要做访问限制，索性就把防火墙关了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#查看防火墙状态</div><div class="line">service iptables status</div><div class="line">#关闭防火墙</div><div class="line">service iptables stop</div><div class="line">#查看防火墙开机启动状态</div><div class="line">chkconfig iptables --list</div><div class="line">#关闭防火墙开机启动</div><div class="line">chkconfig iptables off</div></pre></td></tr></table></figure>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>我们一般不直接使用root用户，会创建一个新的用户来完成我们的实验，这里我们新建一个hadoop用户<br><code>user add hadoop</code><br>接下来为hadoop用户设置密码<br><code>passwd hadoop</code><br>然后我们为hadoop用户授予root权限<br><code>vim /etc/sudoer</code><br>找到root    ALL=(ALL)       ALL    并下面加入以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">## Allow root to run any commands anywhere </div><div class="line">root    ALL=(ALL)       ALL</div><div class="line">hadoop    ALL=(ALL)       ALL</div></pre></td></tr></table></figure></p>
<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>现在我们切换到hadoop用户下进行操作</p>
<p><code>su hadoop</code></p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>我们在根目录下创建一个app文件夹, <code>mkdir app</code>,然后我们将需要弄的文件都解压到app文件夹里面<br>用winscp上传JDK,Hadoop的文件，解压JDK, 执行命令</p>
<p><code>tar -zxvf jdk-8u131-linux-x64.tar.gz -C app</code></p>
<p>解压Hadoop</p>
<p><code>tar -zxvf hadoop-2.7.3.tar.gz -C app</code></p>
<p>这个时候我们将jdk和hadoop都解压到app目录下，接下来我们就开始配置环境了</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div></pre></td></tr></table></figure>
<p>在文件最后添加如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_131</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin</div></pre></td></tr></table></figure>
<p>刷新配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure>
<h3 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h3><p>注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop,这里我们的目录就是在/home/hadoop/app/hadoop-2.7.3/etc/下<br>伪分布式需要修改5个配置文件</p>
<ol>
<li><code>hadoop-env.sh</code><br>这个文件表示hadoop运行环境的文件，找到25行，改成<code>export JAVA_HOME=/home/hadoop/app/jdk1.8.0_131</code><br>这个值原来是${JAVA_HOME}，但是有点问题，老是获取不到正确的值，所以这里我们就直接将它写死</li>
<li><p><code>core-site.xml</code><br>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;!-- 指定HADOOP所使用的文件系统schema（URI），HDFS的老大（NameNode）的地址 --&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">		&lt;value&gt;hdfs://hadoop1:9000&lt;/value&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">	&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class="line">		&lt;value&gt;/home/hadoop/app/hadoop-2.7.3/tmp&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>hdfs-site.xml</code><br>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;!-- 指定HDFS副本的数量 --&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">		&lt;value&gt;1&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>mapred-site.xml</code><br>这里先执行一个命令，重命名模板文件<code>mv mapred-site.xml.template mapred-site.xml</code><br>然后再修改<code>vim mapred-site.xml</code><br>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">	&lt;!-- 指定mr运行在yarn上 --&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">		&lt;value&gt;yarn&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>yarn-site.xml</code><br>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">&lt;!-- Site specific YARN configuration properties --&gt;</div><div class="line">	&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;</div><div class="line">	&lt;property&gt;</div><div class="line">		&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</div><div class="line">		&lt;value&gt;hadoop1&lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">	&lt;!-- reducer获取数据的方式 --&gt;</div><div class="line">    &lt;property&gt;</div><div class="line">		&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">		&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">     &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>5个文件都修改完成后，我们需要将hadoop添加到环境中<br><code>vim /etc/proflie</code><br>加上HADOOP_HOME, 修改文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/home/hadoop/app/jdk1.8.0_131</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin</div><div class="line">export HADOOP_HOME=/home/hadoop/app/hadoop-2.7.3</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</div></pre></td></tr></table></figure></p>
<h2 id="格式化hdfs"><a href="#格式化hdfs" class="headerlink" title="格式化hdfs"></a>格式化hdfs</h2><p>第一次启动的时候我们需要格式化namenode，对namenode进行初始化，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdfs namenode -format (hadoop namenode -format)</div></pre></td></tr></table></figure>
<p>成功的话，会看到 “successfully formatted” 和 “Exitting with status 0″ 的提示，若为 “Exitting with status 1″ 则是出错。</p>
<h2 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h2><p>先启动HDFS: <code>start-dfs.sh</code><br>再启动YARN: <code>start-yarn.sh</code><br>期间会让你多次输入密码，我们在后面配置SSH免密登录之后就不用输入密码了<br>验证是否启动成功，使用jps命令验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">27408 NameNode</div><div class="line">28218 Jps</div><div class="line">27643 SecondaryNameNode</div><div class="line">28066 NodeManager</div><div class="line">27803 ResourceManager</div><div class="line">27512 DataNode</div></pre></td></tr></table></figure></p>
<p>看到以上进程的时候，就说明我们启动成功了</p>
<h3 id="配置SSH免登录"><a href="#配置SSH免登录" class="headerlink" title="配置SSH免登录"></a>配置SSH免登录</h3><p>生成ssh免登陆密钥，进入到我的home目录<br><code>cd ~/.ssh</code>,执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa （四个回车）</div></pre></td></tr></table></figure>
<p>执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）<br>将公钥拷贝到要免登陆的机器上<br><code>ssh-copy-id localhost</code><br>然后我们执行ssh localhost 就可以不用输入密码登录这台机器了</p>
<h3 id="进入Web管理界面"><a href="#进入Web管理界面" class="headerlink" title="进入Web管理界面"></a>进入Web管理界面</h3><p>我们在浏览器里面输入<a href="http://192.168.109.3:50070/" target="_blank" rel="external">http://192.168.109.3:50070/</a><br>可以看到如下图片<br><img src="https://i.loli.net/2017/07/29/597caedef3048.png" alt="web页面1.png"><br><img src="https://i.loli.net/2017/07/30/597dedda81c30.png" alt="web页面2.png"></p>
<p>说明我们的hadooop已经开启成功了</p>
<h1 id="运行mapreduce程序"><a href="#运行mapreduce程序" class="headerlink" title="运行mapreduce程序"></a>运行mapreduce程序</h1><p>好了，我们的环境也搭建成功了，现在来试着跑一下mapreduce程序，进入hadoop的share目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /home/hadoop/app/hadoop-2.7.3/share/hadoop/mapreduce</div></pre></td></tr></table></figure>
<p>看到有以下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">hadoop-mapreduce-client-app-2.7.3.jar</div><div class="line">hadoop-mapreduce-client-common-2.7.3.jar</div><div class="line">hadoop-mapreduce-client-core-2.7.3.jar</div><div class="line">hadoop-mapreduce-client-hs-2.7.3.jar</div><div class="line">hadoop-mapreduce-client-hs-plugins-2.7.3.jar</div><div class="line">hadoop-mapreduce-client-jobclient-2.7.3.jar</div><div class="line">hadoop-mapreduce-client-jobclient-2.7.3-tests.jar</div><div class="line">hadoop-mapreduce-client-shuffle-2.7.3.jar</div><div class="line">hadoop-mapreduce-examples-2.7.3.jar</div><div class="line">lib</div><div class="line">lib-examples</div><div class="line">sources</div></pre></td></tr></table></figure></p>
<h2 id="运算PI圆周率"><a href="#运算PI圆周率" class="headerlink" title="运算PI圆周率"></a>运算PI圆周率</h2><p>这里我们用<code>hadoop-mapreduce-examples-2.7.3.jar</code>的例子跑一下，执行的命令为<br><code>hadoop jar hadoop-mapreduce-examples-2.7.3.jar pi 5 10</code><br>pi是运算圆周率，后面的两个参数代表map的任务数量和map的取样数，取样数越大，运算的结果越精确，这里我们取了5和10作为参数，结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line">Number of Maps  = 5</div><div class="line">Samples per Map = 10</div><div class="line">Wrote input for Map #0</div><div class="line">Wrote input for Map #1</div><div class="line">17/07/20 22:34:51 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:370)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:546)</div><div class="line">Wrote input for Map #2</div><div class="line">17/07/20 22:34:51 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:370)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:546)</div><div class="line">Wrote input for Map #3</div><div class="line">17/07/20 22:34:51 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:370)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:546)</div><div class="line">Wrote input for Map #4</div><div class="line">Starting Job</div><div class="line">17/07/20 22:34:51 INFO client.RMProxy: Connecting to ResourceManager at hadoop1/192.168.109.3:8032</div><div class="line">17/07/20 22:34:52 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeInternal(DFSOutputStream.java:577)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:573)</div><div class="line">17/07/20 22:34:52 INFO input.FileInputFormat: Total input paths to process : 5</div><div class="line">17/07/20 22:34:52 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:370)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:546)</div><div class="line">17/07/20 22:34:52 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:370)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:546)</div><div class="line">17/07/20 22:34:52 INFO mapreduce.JobSubmitter: number of splits:5</div><div class="line">17/07/20 22:34:52 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1500560388081_0003</div><div class="line">17/07/20 22:34:53 INFO impl.YarnClientImpl: Submitted application application_1500560388081_0003</div><div class="line">17/07/20 22:34:53 INFO mapreduce.Job: The url to track the job: http://hadoop1:8088/proxy/application_1500560388081_0003/</div><div class="line">17/07/20 22:34:53 INFO mapreduce.Job: Running job: job_1500560388081_0003</div><div class="line">17/07/20 22:35:08 INFO mapreduce.Job: Job job_1500560388081_0003 running in uber mode : false</div><div class="line">17/07/20 22:35:08 INFO mapreduce.Job:  map 0% reduce 0%</div><div class="line">17/07/20 22:36:14 INFO mapreduce.Job:  map 100% reduce 0%</div><div class="line">17/07/20 22:36:28 INFO mapreduce.Job:  map 100% reduce 100%</div><div class="line">17/07/20 22:36:29 INFO mapreduce.Job: Job job_1500560388081_0003 completed successfully</div><div class="line">17/07/20 22:36:29 INFO mapreduce.Job: Counters: 49</div><div class="line">        File System Counters</div><div class="line">                FILE: Number of bytes read=116</div><div class="line">                FILE: Number of bytes written=714243</div><div class="line">                FILE: Number of read operations=0</div><div class="line">                FILE: Number of large read operations=0</div><div class="line">                FILE: Number of write operations=0</div><div class="line">                HDFS: Number of bytes read=1320</div><div class="line">                HDFS: Number of bytes written=215</div><div class="line">                HDFS: Number of read operations=23</div><div class="line">                HDFS: Number of large read operations=0</div><div class="line">                HDFS: Number of write operations=3</div><div class="line">        Job Counters</div><div class="line">                Launched map tasks=5</div><div class="line">                Launched reduce tasks=1</div><div class="line">                Data-local map tasks=5</div><div class="line">                Total time spent by all maps in occupied slots (ms)=325021</div><div class="line">                Total time spent by all reduces in occupied slots (ms)=8256</div><div class="line">                Total time spent by all map tasks (ms)=325021</div><div class="line">                Total time spent by all reduce tasks (ms)=8256</div><div class="line">                Total vcore-milliseconds taken by all map tasks=325021</div><div class="line">                Total vcore-milliseconds taken by all reduce tasks=8256</div><div class="line">                Total megabyte-milliseconds taken by all map tasks=332821504</div><div class="line">                Total megabyte-milliseconds taken by all reduce tasks=8454144</div><div class="line">        Map-Reduce Framework</div><div class="line">                Map input records=5</div><div class="line">                Map output records=10</div><div class="line">                Map output bytes=90</div><div class="line">                Map output materialized bytes=140</div><div class="line">                Input split bytes=730</div><div class="line">                Combine input records=0</div><div class="line">                Combine output records=0</div><div class="line">                Reduce input groups=2</div><div class="line">                Reduce shuffle bytes=140</div><div class="line">                Reduce input records=10</div><div class="line">                Reduce output records=0</div><div class="line">                Spilled Records=20</div><div class="line">                Shuffled Maps =5</div><div class="line">                Failed Shuffles=0</div><div class="line">                Merged Map outputs=5</div><div class="line">                GC time elapsed (ms)=8989</div><div class="line">                CPU time spent (ms)=9260</div><div class="line">                Physical memory (bytes) snapshot=458428416</div><div class="line">                Virtual memory (bytes) snapshot=12371886080</div><div class="line">                Total committed heap usage (bytes)=624766976</div><div class="line">        Shuffle Errors</div><div class="line">                BAD_ID=0</div><div class="line">                CONNECTION=0</div><div class="line">                IO_ERROR=0</div><div class="line">                WRONG_LENGTH=0</div><div class="line">                WRONG_MAP=0</div><div class="line">                WRONG_REDUCE=0</div><div class="line">        File Input Format Counters</div><div class="line">                Bytes Read=590</div><div class="line">        File Output Format Counters</div><div class="line">                Bytes Written=97</div><div class="line">Job Finished in 98.692 seconds</div><div class="line">Estimated value of Pi is 3.28000000000000000000</div></pre></td></tr></table></figure></p>
<p>我们看最后一行，得出结果为3.28,是我们的样本数量太少了，要是样本数量大一点，结果应该更接近3.14<br>还发现个问题，运行中出现了多次警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">17/07/20 22:34:52 WARN hdfs.DFSClient: Caught exception</div><div class="line">java.lang.InterruptedException</div><div class="line">        at java.lang.Object.wait(Native Method)</div><div class="line">        at java.lang.Thread.join(Thread.java:1252)</div><div class="line">        at java.lang.Thread.join(Thread.java:1326)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.closeResponder(DFSOutputStream.java:609)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.endBlock(DFSOutputStream.java:370)</div><div class="line">        at org.apache.hadoop.hdfs.DFSOutputStream$DataStreamer.run(DFSOutputStream.java:546)</div></pre></td></tr></table></figure></p>
<p>我google了一下，再hadoop issue里面找到了答案<a href="https://issues.apache.org/jira/browse/HDFS-10429" target="_blank" rel="external">https://issues.apache.org/jira/browse/HDFS-10429</a>，发现是bug,忽略就好了，换个hadoop版本也许就没事了，或者修改日志的输出级别</p>
<h2 id="计算单词数量wordcount"><a href="#计算单词数量wordcount" class="headerlink" title="计算单词数量wordcount"></a>计算单词数量wordcount</h2><p>首先我们先新建一个words.txt文件，内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hello world</div><div class="line">hello tom</div><div class="line">hello kevin</div><div class="line">hello jerry</div><div class="line">hello baby</div><div class="line">tom and jerry</div></pre></td></tr></table></figure></p>
<p>然后在hdfs里创建一个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs -mkdir -p /wordcount/input</div></pre></td></tr></table></figure></p>
<p>把文件上传到该目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs -put words.txt /wordcount/input</div></pre></td></tr></table></figure></p>
<p>查看文件是否上传上去了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs -ls /wordcount/input</div></pre></td></tr></table></figure></p>
<p>我们可以看到我们的文件已经成功上传上去了<br>我们发现操作hdfs的命令和操作linux的命令大致都是一样的，大家可以自行去看官方的文档<br>回到刚才的share目录下，继续执行刚才的那个示例文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop jar hadoop-mapreduce-examples-2.7.3.jar wordcount /wordcount/input /wordcount/output</div></pre></td></tr></table></figure>
<p>这里执行的方法是wordcount，第一个参数是输入的文件位置，第二个参数是输出的结果的文件位置<br>执行结束后，我们来看一下输出目录<code>hadoop fs -ls /wordcount/output</code>,发下目录下生成了两个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Found 2 items</div><div class="line">-rw-r--r--   1 hadoop supergroup          0 2017-07-20 23:07 /wordcount/output/_SUCCESS</div><div class="line">-rw-r--r--   1 hadoop supergroup         51 2017-07-20 23:07 /wordcount/output/part-r-00000</div></pre></td></tr></table></figure></p>
<p>查看一下part-r-00000这个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs -cat /wordcount/output/part-r-00000</div></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">and     1</div><div class="line">baby    1</div><div class="line">hello   5</div><div class="line">jerry   2</div><div class="line">kevin   1</div><div class="line">tom     2</div><div class="line">world   1</div></pre></td></tr></table></figure></p>
<p>可以看到，结果是正确的，大功告成</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>接触一个新的技术，安装和配置环境的都是一件比较麻烦的事，可能你第一天就要花费很多时间在搭建环境上面了，可能期间你会遇到各种问题，不过也是锻炼耐心的一个过程，有一个不错的方法可以解决，那就是使用docker容器技术，使用别人搭建好的环境镜像，直接拿来用就可以，这样我们就可以不必花费太多时间在环境问题上，专心学我们的技术，有兴趣的同学可以自行了解下。还有这次的演示例子也只是拿官方的例子来做演示，后面需要自己写程序实现map-reduce,官网上也有很多的例子，所以我觉得看官方其实是最快了解一门技术的方法了，而且一些比较著名的开源项目的文档都是写的比较好的，基本上你看，然后照着demo敲一遍就可以上手了，而且那些资料还是最新的。还有这里也只是演示了伪分布的安装，其实hadoop有三种安装模式：<br>1.独立式:Hadoop运行所有的东西在无后台的单独的JVM中，这种模式适合在开发阶段测试与Debug MapReduce程序。<br>2.伪分布式:Hadoop做为后台应用运行在本地机器，模拟小集群。<br>3.全分布式:Hadoop做为后台应用运行真实的集群电脑中。<br>剩下的就留给读者自己探索吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近几年，大数据，云计算，机器学习成为了非常热门的话题，这些技术运用在了很多的领域，也是在未来很有发展前景的技术。自己最近在接触一些大数据的东西，学习大数据的话自然很有必要先学习Hadoop和Spark。这里我们就来一探Hadoop的究竟吧。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2017/07/29/597c475fd58d4.png&quot; alt=&quot;hadoop-pic1.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="大数据" scheme="https://zgj12138.github.io/blog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hadoop" scheme="https://zgj12138.github.io/blog/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>学习总结 2017-07</title>
    <link href="https://zgj12138.github.io/blog/2017/07/24/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932017-07/"/>
    <id>https://zgj12138.github.io/blog/2017/07/24/学习总结2017-07/</id>
    <published>2017-07-24T15:26:06.000Z</published>
    <updated>2017-08-08T16:08:13.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录个人在平时的学习和总结，不定期更新<br><a id="more"></a></p>
<h1 id="2017-07-23"><a href="#2017-07-23" class="headerlink" title="2017-07-23"></a>2017-07-23</h1><h2 id="调停者模式"><a href="#调停者模式" class="headerlink" title="调停者模式"></a>调停者模式</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。<br>这个示意图中有大量的对象，这些对象既会影响别的对象，又会被别的对象所影响，因此常常叫做同事(Colleague)对象。这些同事对象通过彼此的相互作用形成系统的行为。从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合。这就是过度耦合的系统。<br>如下图所示：<br><img src="https://i.loli.net/2017/07/24/597619455a857.png" alt="调停者模式1.png"><br>通过引入调停者对象(Mediator)，可以将系统的网状结构变成以中介者为中心的星形结构，如下图所示。在这个星形结构中，同事对象不再通过直接的联系与另一个对象发生相互作用；相反的，它通过调停者对象与另一个对象发生相互作用。调停者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。<br><img src="https://i.loli.net/2017/07/24/5976194543a08.png" alt="调停者模式2.png"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>网络拓扑图的星型总线图</strong><br>星型拓扑结构是用一个节点作为中心节点和其他节点直接与中心节点相连构成的网络。<br>中心节点可以是文件服务器，也可以是连接设备。常见的中心节点为集线器。<br><strong>计算机中的主板</strong><br>主板作为电脑里面各个配件之间的交互的桥梁，电脑各个配件的交互主要是通过主板来完成的，每个部件不需要知道其他部件的接口形式，只需要知道主板的接口形式即可，屏蔽了很多交互细节</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计模式是很多人在编程的道路上发现了问题，然后通过思考和实践将对这些问题的解决方式抽象出来，这就是形成了设计模式。我们发现设计模式在很多地方都可以看到影子，这是因为设计模式是一种思想，一种高度抽取用来解决问题的问题的思想，也可以用来解决生活中很多的问题。</p>
<hr>
<h1 id="2017-07-24"><a href="#2017-07-24" class="headerlink" title="2017-07-24"></a>2017-07-24</h1><h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select,poll,epoll"></a>select,poll,epoll</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>都是解决IO多路复用的问题，好处就在于单个process就可以同时处理多个网络连接的IO。基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p> select和poll的本质是一样的，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket，不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。<br> epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</p>
<h2 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>Apache Spark 是个通用的集群计算框架，通过将大量数据集计算任务分配到多台计算机上，提供高效内存计算。Spark 正如其名，最大的特点就是快（Lightning-fast），可比 Hadoop MapReduce 的处理速度快 100 倍。如果你熟悉 Hadoop，那么你知道分布式计算框架要解决两个问题：如何分发数据和如何分发计算。Hadoop 使用 HDFS 来解决分布式数据问题，MapReduce 计算范式提供有效的分布式计算。类似的，Spark 拥有多种语言的函数式编程 API，提供了除 map 和 reduce 之外更多的运算符，这些操作是通过一个称作弹性分布式数据集(resilient distributed datasets, RDDs)的分布式数据框架进行的。</p>
<h3 id="Spark核心组件"><a href="#Spark核心组件" class="headerlink" title="Spark核心组件"></a>Spark核心组件</h3><ol>
<li><p><strong>Spark Core</strong>：包含 Spark 的基本功能；尤其是定义 RDD 的 API、操作以及这两者上的动作。其他 Spark 的库都是构建在 RDD 和 Spark Core 之上的。</p>
</li>
<li><p><strong>Spark SQL</strong>：提供通过 Apache Hive 的 SQL 变体 Hive 查询语言（HiveQL）与 Spark 进行交互的 API。每个数据库表被当做一个 RDD，Spark SQL 查询被转换为 Spark 操作。对熟悉 Hive 和 HiveQL 的人，Spar k可以拿来就用。</p>
</li>
<li><p><strong>Spark Streaming</strong>：允许对实时数据流进行处理和控制。很多实时数据库（如Apache Store）可以处理实时数据。Spark Streaming 允许程序能够像普通 RDD 一样处理实时数据。</p>
</li>
<li><p><strong>MLlib</strong>：一个常用机器学习算法库，算法被实现为对 RDD 的 Spark 操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。之前可选的大数据机器学习库 Mahout，将会转到 Spark，并在未来实现。</p>
</li>
<li><p><strong>GraphX</strong>：控制图、并行图操作和计算的一组算法和工具的集合。GraphX 扩展了 RDD API，包含控制图、创建子图、访问路径上所有顶点的操作。</p>
</li>
</ol>
<p>由于这些组件满足了很多大数据需求，也满足了很多数据科学任务的算法和计算上的需要，Spark 快速流行起来。不仅如此，Spark 也提供了使用 Scala、Java 和Python 编写的 API；满足了不同团体的需求，允许更多数据科学家简便地采用 Spark 作为他们的大数据解决方案。</p>
<h3 id="Spark-体系架构"><a href="#Spark-体系架构" class="headerlink" title="Spark 体系架构"></a>Spark 体系架构</h3><p>Spark体系架构包括如下三个主要组件：</p>
<ul>
<li>数据存储</li>
<li>API</li>
<li>管理框架</li>
</ul>
<p>数据存储：Spark 用 HDFS 文件系统存储数据。它可用于存储任何兼容于 Hadoop 的数据源，包括HDFS，Hbase，Cassandra等。</p>
<p>API：利用 API，应用开发者可以用标准的 API 接口创建基于 Spark 的应用。Spark 提供 Scala，Java 和 Python 三种程序设计语言的 API。<br>Spark基本概念：</p>
<p><code>Application</code>： 用户自己写的 Spark 应用程序，批处理作业的集合。Application 的 main 方法为应用程序的入口，用户通过 Spark 的 API，定义了 RDD 和对 RDD 的操作。</p>
<p><code>SparkContext</code>： Spark 最重要的 API，用户逻辑与 Spark 集群主要的交互接口，它会和 Cluster Master 交互，包括向它申请计算资源等。</p>
<p><code>Driver 和 Executor</code>：Spark 在执行每个 Application 的过程中会启动 Driver 和 Executor 两种 JVM 进程。Driver 进程为主控进程，负责执行用户 Application 中的 main 方法，提交 Job，并将 Job 转化为 Task，在各个 Executor 进程间协调 Task 的调度。运行在Worker上 的 Executor 进程负责执行 Task，并将结果返回给 Driver，同时为需要缓存的 RDD 提供存储功能。<br>资源管理：</p>
<p>一组计算机的集合，每个计算机节点作为独立的计算资源，又可以虚拟出多个具备计算能力的虚拟机，这些虚拟机是集群中的计算单元。Spark 的核心模块专注于调度和管理虚拟机之上分布式计算任务的执行，集群中的计算资源则交给 Cluster Manager 这个角色来管理，Cluster Manager 可以为自带的Standalone、或第三方的 Yarn和 Mesos。</p>
<p>Cluster Manager 一般采用 Master-Slave 结构。以 Yarn 为例，部署 ResourceManager 服务的节点为 Master，负责集群中所有计算资源的统一管理和分配；部署 NodeManager 服务的节点为Slave，负责在当前节点创建一个或多个具备独立计算能力的 JVM 实例，在 Spark 中，这些节点也叫做 Worker。</p>
<p>另外还有一个 Client 节点的概念，是指用户提交Spark Application 时所在的节点。</p>
<p>弹性分布式数据集(RDD)：</p>
<p>弹性分布式数据集(RDD)是 Spark 框架中的核心概念。可以将 RDD 视作数据库中的一张表。其中可以保存任何类型的数据。Spark 将数据存储在不同分区上的 RDD 之中。</p>
<p>RDD 可以帮助重新安排计算并优化数据处理过程。</p>
<p>此外，它还具有容错性，因为RDD知道如何重新创建和重新计算数据集。</p>
<p>RDD 是<strong>不可变</strong>的。你可以用变换（Transformation）修改 RDD，但是这个变换所返回的是一个全新的RDD，而原有的 RDD 仍然保持不变。</p>
<p>RDD 支持两种类型的操作：</p>
<p><strong>变换（Transformation）</strong> 变换的返回值是一个新的 RDD 集合，而不是单个值。调用一个变换方法，不会有任何求值计算，它只获取一个 RDD 作为参数，然后返回一个新的 RDD。 变换函数包括：map，filter，flatMap，groupByKey，reduceByKey，aggregateByKey，pipe和coalesce。</p>
<p><strong>行动（Action）</strong> 行动操作计算并返回一个新的值。当在一个 RDD 对象上调用行动函数时，会在这一时刻计算全部的数据处理查询并返回结果值。 行动操作包括：reduce，collect，count，first，take，countByKey 以及 foreach。</p>
<h3 id="Java客户端在本地跑数据配置"><a href="#Java客户端在本地跑数据配置" class="headerlink" title="Java客户端在本地跑数据配置"></a>Java客户端在本地跑数据配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SparkConf sparkConf = <span class="keyword">new</span> SparkConf()</div><div class="line">        .setAppName(<span class="string">"spark01"</span>)</div><div class="line">        .setMaster(<span class="string">"local[4]"</span>);</div><div class="line">sc = <span class="keyword">new</span> JavaSparkContext(sparkConf);</div></pre></td></tr></table></figure>
<p>local代表的是在本地跑，[4]指的是创建4个节点</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>跟着官网首先在虚拟机上安装了spark，然后使用scala连接到spark-shell，试着写了几个demo,发现hadoop的map,reduce操作也在里面，还有Java8中对stream中的操作，基本上思想是一样的，map变换，延迟执行，reduce汇聚。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录个人在平时的学习和总结，不定期更新&lt;br&gt;
    
    </summary>
    
      <category term="学习总结" scheme="https://zgj12138.github.io/blog/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Java多线程爬虫爬取京东商品信息</title>
    <link href="https://zgj12138.github.io/blog/2017/07/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF/"/>
    <id>https://zgj12138.github.io/blog/2017/07/15/Java多线程爬虫爬取京东商品信息/</id>
    <published>2017-07-15T09:47:18.000Z</published>
    <updated>2017-07-16T01:47:48.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络爬虫，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。爬虫可以通过模拟浏览器访问网页，从而获取数据，一般网页里会有很多个URL,爬虫可以访问这些URL到达其他网页，相当于形成了一种数据结构——图，我们通过广度优先搜索和深度优先搜索的方式来遍历这个图，从而做到不断爬取数据的目的。最近准备做一个电商网站，商品的原型就打算从一些电商网站上爬取，这里使用了HttpClient和Jsoup实现了一个简答的爬取商品的demo,采用了多线程的方式，并将爬取的数据持久化到了数据库。<br><a id="more"></a></p>
<h2 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h2><h3 id="整体使用技术"><a href="#整体使用技术" class="headerlink" title="整体使用技术"></a>整体使用技术</h3><p>我IDE使用了Spring Tool Suite(sts)，你也可以使用Eclipse或者是IDEA，安利使用IDEA，真的好用，谁用谁知道。<br>整个项目使用Maven进行构建吗，使用Springboot进行自动装配，使用HttpClient对网页进行抓取，Jsoup对网页进行解析，数据库连接池使用Druild，还使用了工具类Guava和Commons.lang3。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>在sts里面新建一个maven工程，创建如下的包<br><img src="https://i.loli.net/2017/07/15/5969d99e3d9e7.png" alt="项目结构.png"></p>
<ul>
<li>common 一些通用工具类</li>
<li>constant 系统常量</li>
<li>dao 数据库访问层</li>
<li>service 服务层</li>
<li>handler 调度控制层</li>
<li>entity 实体层<br><br><br>这样分层的意义是使得项目结构层次清晰，每层都有着其对应的职责，便于扩展和维护</li>
</ul>
<h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>这里使用maven进行构建，还没有了解maven的童鞋自行去了解，使用maven的好处是不用自己导入jar包和完整的生命周期控制，注意，使用阿里云的镜像速度回加快很多。项目的<code>pom.xml</code>文件如下<br><strong>pom.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.exmaple<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spider-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>spider-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">jsoup.version</span>&gt;</span>1.10.3<span class="tag">&lt;/<span class="name">jsoup.version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">guava.version</span>&gt;</span>22.0<span class="tag">&lt;/<span class="name">guava.version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">lang3.version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">lang3.version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.42<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- httpclient --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- jsoup --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jsoup.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- guava --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;guava.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- commons-lang3 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.34<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>spider-demo<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="application-yml文件"><a href="#application-yml文件" class="headerlink" title="application.yml文件"></a>application.yml文件</h3><p>spring boot的配置文件有两种形式，放<code>在src/main/resources</code>目录下，分别是<code>application.yml</code>和<code>application.properties</code><br>这里为了配置更加简洁，使用了<code>application.yml</code>作为我们的配置文件<br><strong>application.yml</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mysql</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">    datasource:</span></div><div class="line"><span class="attr">        type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></div><div class="line"><span class="attr">        driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></div><div class="line"><span class="attr">        url:</span> <span class="attr">jdbc:mysql://localhost:3306/spider?useUnicode=true&amp;characterEncoding=UTF-8&amp;&amp;useSSL=true</span></div><div class="line"><span class="attr">        username:</span> <span class="string">root</span></div><div class="line"><span class="attr">        password:</span> <span class="number">123</span></div></pre></td></tr></table></figure></p>
<p>这里可以在url，username和pssword里换成自己环境对应的配置</p>
<h3 id="sql文件"><a href="#sql文件" class="headerlink" title="sql文件"></a>sql文件</h3><p>这里我们创建了一个数据库和一张表，以便后面将商品信息持久化到数据库<br><strong>db.sql</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">USE</span> spider;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`goods_info`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'ID'</span>,</div><div class="line">  <span class="string">`goods_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</div><div class="line">  <span class="string">`goods_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品名称'</span>,</div><div class="line">  <span class="string">`img_url`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品图片地址'</span>,</div><div class="line">  <span class="string">`goods_price`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品标价'</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'商品信息表'</span>;</div></pre></td></tr></table></figure></p>
<h2 id="网页的分析"><a href="#网页的分析" class="headerlink" title="网页的分析"></a>网页的分析</h2><h3 id="网址URL的分析"><a href="#网址URL的分析" class="headerlink" title="网址URL的分析"></a>网址URL的分析</h3><p>我们要爬取的网页的URL的基本地址是<code>https://search.jd.com/Search</code><br>我们打开这个网页，在搜索框内搜索零食，我们看一下我们的浏览器的地址栏的URL的变化，发现浏览器的地址栏变成了<code>https://search.jd.com/Search?keyword=零食&amp;enc=utf-8&amp;wq=零食&amp;pvid=2c636c9dc26c4e6e88e0dea0357b81a3</code><br>我们就可以对参数进行分析，<code>keyword</code>和<code>wq</code>应该是代表要搜索的关键字，<code>enc</code>代表的编码，·<code>pvid</code>不知道是什么，我们吧这个参数去掉看能不能访问<code>https://search.jd.com/Search?keyword=零食&amp;enc=utf-8&amp;wq=零食</code>，发现这个URL也是可以正常访问到这个网址的，那么我们就可以暂时忽略这个参数，参数就设置就设置<code>keyword</code>,<code>wq</code>和<code>enc</code><br>这里我们要设置的参数就是</p>
<ul>
<li>keyword 零食</li>
<li>wq 零食</li>
<li>enc utf-8</li>
</ul>
<h3 id="网页内容的分析"><a href="#网页内容的分析" class="headerlink" title="网页内容的分析"></a>网页内容的分析</h3><p>我们打开我们要爬取数据的页面<br><img src="https://i.loli.net/2017/07/16/596a4111d104b.png" alt="商品.png"><br>使用浏览器-检查元素<br><img src="https://i.loli.net/2017/07/16/596a41e791287.png" alt="商品源代码.png"><br>通过查看源码，我们发现JD的商品列表放在id是J_goodsList的div下的的class是gl-warp clearfix的ul标签的gl-item的li标签下<br>再分别审查各个元素，我们发现</p>
<ul>
<li>li标签的data-sku的属性值就是商品的ID</li>
<li>li标签下的class为p-name p-name-type-2的em的值就是商品的名称</li>
<li>li标签下的class为p-price的strong标签下的i标签的值是商品的价格</li>
<li>li标签下的class为p-img的img标签的src值就是商品的图片URL</li>
</ul>
<p>对网页进行了分析以后，我们就可以通过对DOM结点的选择来筛选我们想要的数据了</p>
<h2 id="代码的编写"><a href="#代码的编写" class="headerlink" title="代码的编写"></a>代码的编写</h2><p>这里我们封装了HttpClientUtils作为我们的工具类，以便以后使用</p>
<h3 id="HttpClientUtils工具类"><a href="#HttpClientUtils工具类" class="headerlink" title="HttpClientUtils工具类"></a>HttpClientUtils工具类</h3><p><strong>HttpClient.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.common;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Map.Entry;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</div><div class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</div><div class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</div><div class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</div><div class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</div><div class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</div><div class="line"><span class="keyword">import</span> org.apache.http.entity.ContentType;</div><div class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</div><div class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</div><div class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</div><div class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</div><div class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.exmaple.spider.constant.SysConstant;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * HttpClient工具类</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年7月14日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtils</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET_METHOD = <span class="string">"GET"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String POST_METHOD = <span class="string">"POST"</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * GET请求</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> url</div><div class="line">	 *            请求url</div><div class="line">	 * <span class="doctag">@param</span> headers</div><div class="line">	 *            头部</div><div class="line">	 * <span class="doctag">@param</span> params</div><div class="line">	 *            参数</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendGet</span><span class="params">(String url, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; params)</span> </span>&#123;</div><div class="line">		<span class="comment">// 创建HttpClient对象</span></div><div class="line">		CloseableHttpClient client = HttpClients.createDefault();</div><div class="line">		StringBuilder reqUrl = <span class="keyword">new</span> StringBuilder(url);</div><div class="line">		String result = <span class="string">""</span>;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 设置param参数</div><div class="line">		 */</div><div class="line">		<span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">			reqUrl.append(<span class="string">"?"</span>);</div><div class="line">			<span class="keyword">for</span> (Entry&lt;String, String&gt; param : params.entrySet()) &#123;</div><div class="line">				reqUrl.append(param.getKey() + <span class="string">"="</span> + param.getValue() + <span class="string">"&amp;"</span>);</div><div class="line">			&#125;</div><div class="line">			url = reqUrl.subSequence(<span class="number">0</span>, reqUrl.length() - <span class="number">1</span>).toString();</div><div class="line">		&#125;</div><div class="line">		logger.debug(<span class="string">"[url:"</span> + url + <span class="string">",method:"</span> + GET_METHOD + <span class="string">"]"</span>);</div><div class="line">		HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 设置头部</div><div class="line">		 */</div><div class="line">		logger.debug(<span class="string">"Header\n"</span>);</div><div class="line">		<span class="keyword">if</span> (headers != <span class="keyword">null</span> &amp;&amp; headers.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (Entry&lt;String, String&gt; header : headers.entrySet()) &#123;</div><div class="line">				httpGet.addHeader(header.getKey(), header.getValue());</div><div class="line">				logger.debug(header.getKey() + <span class="string">" : "</span> + header.getValue());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		CloseableHttpResponse response = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			response = client.execute(httpGet);</div><div class="line">			<span class="comment">/**</span></div><div class="line">			 * 请求成功</div><div class="line">			 */</div><div class="line">			<span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</div><div class="line">				HttpEntity entity = response.getEntity();</div><div class="line">				result = EntityUtils.toString(entity, SysConstant.DEFAULT_CHARSET);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			logger.error(<span class="string">"网络请求出错，请检查原因"</span>);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="comment">// 关闭资源</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">					response.close();</div><div class="line">				&#125;</div><div class="line">				client.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				logger.error(<span class="string">"网络关闭错误错，请检查原因"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * POST请求</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> url</div><div class="line">	 *            请求url</div><div class="line">	 * <span class="doctag">@param</span> headers</div><div class="line">	 *            头部</div><div class="line">	 * <span class="doctag">@param</span> params</div><div class="line">	 *            参数</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sendPost</span><span class="params">(String url, Map&lt;String, String&gt; headers, Map&lt;String, String&gt; params)</span> </span>&#123;</div><div class="line">		CloseableHttpClient client = HttpClients.createDefault();</div><div class="line">		String result = <span class="string">""</span>;</div><div class="line">		HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 设置参数</div><div class="line">		 */</div><div class="line">		<span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">			List&lt;NameValuePair&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">			<span class="keyword">for</span> (Entry&lt;String, String&gt; param : params.entrySet()) &#123;</div><div class="line">				paramList.add(<span class="keyword">new</span> BasicNameValuePair(param.getKey(), param.getValue()));</div><div class="line">			&#125;</div><div class="line">			logger.debug(<span class="string">"[url: "</span> + url + <span class="string">",method: "</span> + POST_METHOD + <span class="string">"]"</span>);</div><div class="line">			<span class="comment">// 模拟表单提交</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(paramList, SysConstant.DEFAULT_CHARSET);</div><div class="line">				httpPost.setEntity(entity);</div><div class="line">			&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">				logger.error(<span class="string">"不支持的编码"</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">/**</span></div><div class="line">			 * 设置头部</div><div class="line">			 */</div><div class="line">			<span class="keyword">if</span> (headers != <span class="keyword">null</span> &amp;&amp; headers.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">				logger.debug(<span class="string">"Header\n"</span>);</div><div class="line">				<span class="keyword">if</span> (headers != <span class="keyword">null</span> &amp;&amp; headers.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">for</span> (Entry&lt;String, String&gt; header : headers.entrySet()) &#123;</div><div class="line">						httpPost.addHeader(header.getKey(), header.getValue());</div><div class="line">						logger.debug(header.getKey() + <span class="string">" : "</span> + header.getValue());</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			CloseableHttpResponse response = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				response = client.execute(httpPost);</div><div class="line">				HttpEntity entity = response.getEntity();</div><div class="line">				result = EntityUtils.toString(entity, SysConstant.DEFAULT_CHARSET);</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				logger.error(<span class="string">"网络请求出错，请检查原因"</span>);</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">						response.close();</div><div class="line">					&#125;</div><div class="line">					client.close();</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					logger.error(<span class="string">"网络关闭错误"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * post请求发送json</div><div class="line">	 * <span class="doctag">@param</span> url</div><div class="line">	 * <span class="doctag">@param</span> json</div><div class="line">	 * <span class="doctag">@param</span> headers</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">senPostJson</span><span class="params">(String url, String json, Map&lt;String, String&gt; headers)</span> </span>&#123;</div><div class="line">		CloseableHttpClient client = HttpClients.createDefault();</div><div class="line">		String result = <span class="string">""</span>;</div><div class="line">		HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</div><div class="line">		StringEntity stringEntity = <span class="keyword">new</span> StringEntity(json, ContentType.APPLICATION_JSON);</div><div class="line">		httpPost.setEntity(stringEntity);</div><div class="line">		logger.debug(<span class="string">"[url: "</span> + url + <span class="string">",method: "</span> + POST_METHOD + <span class="string">", json: "</span> + json + <span class="string">"]"</span>);</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 设置头部</div><div class="line">		 */</div><div class="line">		<span class="keyword">if</span> (headers != <span class="keyword">null</span> &amp;&amp; headers.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">			logger.debug(<span class="string">"Header\n"</span>);</div><div class="line">			<span class="keyword">if</span> (headers != <span class="keyword">null</span> &amp;&amp; headers.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">for</span> (Entry&lt;String, String&gt; header : headers.entrySet()) &#123;</div><div class="line">					httpPost.addHeader(header.getKey(), header.getValue());</div><div class="line">					logger.debug(header.getKey() + <span class="string">" : "</span> + header.getValue());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		CloseableHttpResponse response = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			response = client.execute(httpPost);</div><div class="line">			HttpEntity entity = response.getEntity();</div><div class="line">			result = EntityUtils.toString(entity, SysConstant.DEFAULT_CHARSET);</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			logger.error(<span class="string">"网络请求出错，请检查原因"</span>);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">					response.close();</div><div class="line">				&#125;</div><div class="line">				client.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				logger.error(<span class="string">"网络关闭错误"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SyConstant-java-系统常量"><a href="#SyConstant-java-系统常量" class="headerlink" title="SyConstant.java 系统常量"></a>SyConstant.java 系统常量</h3><p><strong>SysConstant.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.constant;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 系统全局常量</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年7月15日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SysConstant</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 系统默认字符集</div><div class="line">	 */</div><div class="line">	String DEFAULT_CHARSET = <span class="string">"utf-8"</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 需要爬取的网站</div><div class="line">	 */</div><div class="line">	String BASE_URL = <span class="string">"https://search.jd.com/Search"</span>;</div><div class="line">	</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Header</span> </span>&#123;</div><div class="line">		String ACCEPT = <span class="string">"Accept"</span>;</div><div class="line">		String ACCEPT_ENCODING = <span class="string">"Accept-Encoding"</span>;</div><div class="line">		String ACCEPT_LANGUAGE = <span class="string">"Accept-Language"</span>;</div><div class="line">		String CACHE_CONTROL = <span class="string">"Cache-Controle"</span>;</div><div class="line">		String COOKIE = <span class="string">"Cookie"</span>;</div><div class="line">		String HOST = <span class="string">"Host"</span>;</div><div class="line">		String PROXY_CONNECTION = <span class="string">"Proxy-Connection"</span>;</div><div class="line">		String REFERER = <span class="string">"Referer"</span>;</div><div class="line">		String USER_AGENT = <span class="string">"User-Agent"</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认日期格式</div><div class="line">	 */</div><div class="line">	String DEFAULT_DATE_FORMAT = <span class="string">"yyy-MM-dd HH:mm:ss"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="GoodsInfo-商品信息"><a href="#GoodsInfo-商品信息" class="headerlink" title="GoodsInfo 商品信息"></a>GoodsInfo 商品信息</h3><p><strong>GoodsInfo.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.entity;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsInfo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String goodsId;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String goodsName;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String imgUrl;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String goodsPrice;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getGoodsId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> goodsId;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsId</span><span class="params">(String goodsId)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.goodsId = goodsId;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getGoodsName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> goodsName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsName</span><span class="params">(String goodsName)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.goodsName = goodsName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getImgUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> imgUrl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgUrl</span><span class="params">(String imgUrl)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.imgUrl = imgUrl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getGoodsPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> goodsPrice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsPrice</span><span class="params">(String goodsPrice)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.goodsPrice = goodsPrice;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GoodsInfo</span><span class="params">(String goodsId, String goodsName, String imgUrl, String goodsPrice)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.goodsId = goodsId;</div><div class="line">		<span class="keyword">this</span>.goodsName = goodsName;</div><div class="line">		<span class="keyword">this</span>.imgUrl = imgUrl;</div><div class="line">		<span class="keyword">this</span>.goodsPrice = goodsPrice;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="GoodsInfoDao-商品信息Dao层"><a href="#GoodsInfoDao-商品信息Dao层" class="headerlink" title="GoodsInfoDao 商品信息Dao层"></a>GoodsInfoDao 商品信息Dao层</h3><p>因为这里仅仅涉及到把商品信息写入到数据库比较简单的操作，并没有使用MyBatis或者Hibernate框架，只是使用了Spring的JdbcTemplate对数据进行插入操作<br><strong>GoodsInfoDao.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.dao;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.exmaple.spider.entity.GoodsInfo;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 商品Dao层</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年7月15日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodsInfoDao</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 插入商品信息</div><div class="line">	 * <span class="doctag">@param</span> infos</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveBatch</span><span class="params">(List&lt;GoodsInfo&gt; infos)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>GoodsInfoDaoImpl.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.dao.impl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.exmaple.spider.dao.GoodsInfoDao;</div><div class="line"><span class="keyword">import</span> com.exmaple.spider.entity.GoodsInfo;</div><div class="line"></div><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsInfoDaoImpl</span> <span class="keyword">implements</span> <span class="title">GoodsInfoDao</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> JdbcTemplate jdbcTemplate;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBatch</span><span class="params">(List&lt;GoodsInfo&gt; infos)</span> </span>&#123;</div><div class="line">		String sql = <span class="string">"REPLACE INTO goods_info("</span> + <span class="string">"goods_id,"</span> + <span class="string">"goods_name,"</span> + <span class="string">"goods_price,"</span> + <span class="string">"img_url) "</span></div><div class="line">				+ <span class="string">"VALUES(?,?,?,?)"</span>;</div><div class="line">		<span class="keyword">for</span>(GoodsInfo info : infos) &#123;</div><div class="line">			jdbcTemplate.update(sql, info.getGoodsId(), info.getGoodsName(), info.getGoodsPrice(), info.getImgUrl());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>商品的Dao层实现了向数据库里插入商品信息，使用JdbcTemplate和占位符的方式设置sql语句</p>
<h3 id="SpiderService-爬虫服务层"><a href="#SpiderService-爬虫服务层" class="headerlink" title="SpiderService 爬虫服务层"></a>SpiderService 爬虫服务层</h3><p><strong>SpiderService.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</div><div class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</div><div class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</div><div class="line"><span class="keyword">import</span> com.exmaple.spider.common.HttpClientUtils;</div><div class="line"><span class="keyword">import</span> com.exmaple.spider.constant.SysConstant;</div><div class="line"><span class="keyword">import</span> com.exmaple.spider.dao.GoodsInfoDao;</div><div class="line"><span class="keyword">import</span> com.exmaple.spider.entity.GoodsInfo;</div><div class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</div><div class="line"></div><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiderService</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SpiderService.class);</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> GoodsInfoDao goodsInfoDao;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String HTTPS_PROTOCOL = <span class="string">"https:"</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spiderData</span><span class="params">(String url, Map&lt;String, String&gt; params)</span> </span>&#123;</div><div class="line">		String html = HttpClientUtils.sendGet(url, <span class="keyword">null</span>, params);</div><div class="line">		<span class="keyword">if</span>(!StringUtils.isBlank(html)) &#123;</div><div class="line">			List&lt;GoodsInfo&gt; goodsInfos =parseHtml(html);</div><div class="line">			goodsInfoDao.saveBatch(goodsInfos);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解析html</div><div class="line">	 * <span class="doctag">@param</span> html</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> List&lt;GoodsInfo&gt; <span class="title">parseHtml</span><span class="params">(String html)</span> </span>&#123;</div><div class="line">		<span class="comment">//商品集合</span></div><div class="line">		List&lt;GoodsInfo&gt; goods = Lists.newArrayList();</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 获取dom并解析</div><div class="line">		 */</div><div class="line">		Document document = Jsoup.parse(html);</div><div class="line">		Elements elements = document.</div><div class="line">				select(<span class="string">"ul[class=gl-warp clearfix]"</span>).select(<span class="string">"li[class=gl-item]"</span>);</div><div class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(Element element : elements) &#123;</div><div class="line">			String goodsId = element.attr(<span class="string">"data-sku"</span>);</div><div class="line">			String goodsName = element.select(<span class="string">"div[class=p-name p-name-type-2]"</span>).select(<span class="string">"em"</span>).text();</div><div class="line">			String goodsPrice = element.select(<span class="string">"div[class=p-price]"</span>).select(<span class="string">"strong"</span>).select(<span class="string">"i"</span>).text();</div><div class="line">			String imgUrl = HTTPS_PROTOCOL + element.select(<span class="string">"div[class=p-img]"</span>).select(<span class="string">"a"</span>).select(<span class="string">"img"</span>).attr(<span class="string">"src"</span>);</div><div class="line">			GoodsInfo goodsInfo = <span class="keyword">new</span> GoodsInfo(goodsId, goodsName, imgUrl, goodsPrice);</div><div class="line">			goods.add(goodsInfo);</div><div class="line">			String jsonStr = JSON.toJSONString(goodsInfo);</div><div class="line">			logger.info(<span class="string">"成功爬取【"</span> + goodsName + <span class="string">"】的基本信息 "</span>);</div><div class="line">			logger.info(jsonStr);</div><div class="line">			<span class="keyword">if</span>(index ++ == <span class="number">9</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> goods;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Service层通过使用HttpClientUtils模拟浏览器访问页面，然后再使用Jsoup对页面进行解析，Jsoup的使用和Jquery的DOM结点选取基本相似，可以看作是java版的Jquery，如果写过Jquery的人基本上就可以看出是什么意思。<br>每抓取一条信息就会打印一次记录，而且使用fastjson将对象转换成json字符串并输出<br>在写测试代码的时候发现，发现爬取的数据只有前10条是完整的，后面的爬取的有些是不完整的，按道理来说是对于整个页面都是通用的，就是不知道为什么只有前面才是完整的，排查了很久没用发现原因，这里就只选择了前面的10条作为要爬取的数据<br>我们了解到，我们要爬取数据前要分析我们要爬取的数据有哪些，再分析网友的结构，然后对网页进行解析，选取对应的DOM或者使用正则表达式筛选，思路首先要清晰，有了思路之后剩下的也只是把你的思路翻译成代码而已了。</p>
<h3 id="SpiderHandler-爬虫调度处理器"><a href="#SpiderHandler-爬虫调度处理器" class="headerlink" title="SpiderHandler 爬虫调度处理器"></a>SpiderHandler 爬虫调度处理器</h3><p><strong>SpiderHandler.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider.handler;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.FastDateFormat;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.exmaple.spider.constant.SysConstant;</div><div class="line"><span class="keyword">import</span> com.exmaple.spider.service.SpiderService;</div><div class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 爬虫调度处理器</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年7月15日</div><div class="line"> */</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiderHandler</span> </span>&#123;</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> SpiderService spiderService;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SpiderHandler.class);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spiderData</span><span class="params">()</span> </span>&#123;</div><div class="line">		logger.info(<span class="string">"爬虫开始...."</span>);</div><div class="line">		Date startDate = <span class="keyword">new</span> Date();</div><div class="line">		<span class="comment">// 使用现线程池提交任务</span></div><div class="line">		ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line">		<span class="comment">//引入countDownLatch进行线程同步，使主线程等待线程池的所有任务结束，便于计时</span></div><div class="line">		CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">201</span>; i += <span class="number">2</span>) &#123;</div><div class="line">			Map&lt;String, String&gt; params = Maps.newHashMap();</div><div class="line">			params.put(<span class="string">"keyword"</span>, <span class="string">"零食"</span>);</div><div class="line">			params.put(<span class="string">"enc"</span>, <span class="string">"utf-8"</span>);</div><div class="line">			params.put(<span class="string">"wc"</span>, <span class="string">"零食"</span>);</div><div class="line">			params.put(<span class="string">"page"</span>, i + <span class="string">""</span>);</div><div class="line">			executorService.submit(() -&gt; &#123;</div><div class="line">				spiderService.spiderData(SysConstant.BASE_URL, params);</div><div class="line">				countDownLatch.countDown();</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			countDownLatch.await();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		executorService.shutdown();</div><div class="line">		Date endDate = <span class="keyword">new</span> Date();</div><div class="line"></div><div class="line">		FastDateFormat fdf = FastDateFormat.getInstance(SysConstant.DEFAULT_DATE_FORMAT);</div><div class="line">		logger.info(<span class="string">"爬虫结束...."</span>);</div><div class="line">		logger.info(<span class="string">"[开始时间:"</span> + fdf.format(startDate) + <span class="string">",结束时间:"</span> + fdf.format(endDate) + <span class="string">",耗时:"</span></div><div class="line">				+ (endDate.getTime() - startDate.getTime()) + <span class="string">"ms]"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SpiderHandelr作为一个爬虫服务调度处理器，这里采用了<code>ExecutorService</code>线程池创建了5个线程进行多线程爬取，我们通过翻页发现，翻页过后地址URL多了一个<code>page</code>参数，而且这个参数还只能是奇数才有效，也就是<code>page</code>为1,3，5,7……代表第1,2,3,4……页。这里就只爬了100页，每页10条数据，将<code>page</code>作为不同的参数传给不同的任务。<br>这里我想统计一下整个爬取任务所用的时间，假如不使用同步工具类的话，因为任务是分到线程池中去运行的，而主线程会继续执行下去，主线程和线程池中的线程是独立运行的，主线程会提前结束，所以就无法统计时间。<br>这里我们使用CountDownLatch同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。也就是说可以让主线程等待线程池内的线程执行结束再继续执行，里面维护了一个计数器，开始的时候构造计数器的初始数量，每个线程执行结束的时候调用countdown()方法，计数器就减1，调用await()方法，假如计数器不为0就会阻塞，假如计数器为0了就可以继续往下执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">executorService.submit(() -&gt; &#123;</div><div class="line">	spiderService.spiderData(SysConstant.BASE_URL, params);</div><div class="line">	countDownLatch.countDown();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里使用了Java8中的lambda表达式替代了匿名内部类，详细的可以自行去了解<br>这里还可以根据自己的业务需求做一些代码的调整和优化，比如实现定时任务爬取等等</p>
<h3 id="App-java-Spring-Boot启动类"><a href="#App-java-Spring-Boot启动类" class="headerlink" title="App.java Spring Boot启动类"></a>App.java Spring Boot启动类</h3><p><strong>App.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.exmaple.spider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.exmaple.spider.handler.SpiderHandler;</div><div class="line"></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">	<span class="keyword">private</span> SpiderHandler spiderHandler;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		SpringApplication.run(App.class, args);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@PostConstruct</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">		spiderHandler.spiderData();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<code>@PostConstruct</code>注解会在spring容器实例化bean之前执行这个方法</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>我们以Spring Boot App的方式运行App.java文件，得到的结果如下：<br><img src="https://i.loli.net/2017/07/16/596a4c45cdc24.png" alt="爬取信息.png"><br>我们在看一下数据库内的信息<br><img src="https://i.loli.net/2017/07/16/596a4c44de164.png" alt="数据库记录.png"><br>发现数据库也有信息了，大功告成</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写一个简单的爬虫其实也不难，但是其中也有不少的知识点需要梳理和记忆，发现问题或者是错误，查google，查文档，一点点debug去调试，最终把问题一点点的解决，编程其实需要是解决问题的能力，这种的能力的锻炼需要我们去多写代码，写完了代码之后还要多思考，思考为什么要这样写？还有没有更好的实现方式？为什么会出问题？需要怎么解决？这才是一名优秀的程序员应该养成的习惯，共勉！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;网络爬虫，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。爬虫可以通过模拟浏览器访问网页，从而获取数据，一般网页里会有很多个URL,爬虫可以访问这些URL到达其他网页，相当于形成了一种数据结构——图，我们通过广度优先搜索和深度优先搜索的方式来遍历这个图，从而做到不断爬取数据的目的。最近准备做一个电商网站，商品的原型就打算从一些电商网站上爬取，这里使用了HttpClient和Jsoup实现了一个简答的爬取商品的demo,采用了多线程的方式，并将爬取的数据持久化到了数据库。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zgj12138.github.io/blog/categories/Java/"/>
    
    
      <category term="爬虫" scheme="https://zgj12138.github.io/blog/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="java" scheme="https://zgj12138.github.io/blog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群的原理的搭建</title>
    <link href="https://zgj12138.github.io/blog/2017/07/08/Redis%E9%9B%86%E7%BE%A4/"/>
    <id>https://zgj12138.github.io/blog/2017/07/08/Redis集群/</id>
    <published>2017-07-08T12:00:21.000Z</published>
    <updated>2017-08-08T16:06:55.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis 是我们目前大规模使用的缓存中间件，由于它强大高效而又便捷的功能，得到了广泛的使用。单节点的Redis已经就达到了很高的性能，为了提高可用性我们可以使用Redis集群。本文参考了Rdis的官方文档和使用Redis官方提供的Redis Cluster工具搭建Rdis集群。</p>
<p><strong>注意</strong> ：Redis的版本要在3.0以上,截止今天，Redis的版本是3.2.9，本教程也使用3.2.9作为教程<br><a id="more"></a></p>
<h1 id="Redis集群的概念"><a href="#Redis集群的概念" class="headerlink" title="Redis集群的概念"></a>Redis集群的概念</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。</p>
<p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的错误。</p>
<p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<p>Redis 集群提供了以下两个好处：</p>
<ul>
<li>将数据自动切分（split）到多个节点的能力。</li>
<li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li>
</ul>
<h2 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h2><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p>
<ul>
<li>节点 A 负责处理 0 号至 5500 号哈希槽。</li>
<li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li>
<li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li>
</ul>
<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：<br>我现在想设置一个key,叫<code>my_name</code>:</p>
<p><code>set my_name zhangguoji</code></p>
<p>按照Redis Cluster的哈希槽算法，<code>CRC16(&#39;my_name&#39;)%16384 = 2412</code> 那么这个key就被分配到了节点A上<br>同样的，当我连接(A,B,C)的任意一个节点想获取<code>my_name</code>这个key,都会转到节点A上<br>再比如<br>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。<br>增加一个D节点的结果可能如下：</p>
<ul>
<li>节点A覆盖1365-5460</li>
<li>节点B覆盖6827-10922</li>
<li>节点C覆盖12288-16383</li>
<li>节点D覆盖0-1364,5461-6826,10923-1228</li>
</ul>
<p>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。<br>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。<br>所以,Redis Cluster的模型大概是这样的形状<br><img src="https://ooo.0o0.ooo/2017/07/06/595dab1f2378b.jpg" alt="082248582749859.jpg"></p>
<h2 id="主从复制模型"><a href="#主从复制模型" class="headerlink" title="主从复制模型"></a>主从复制模型</h2><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p>
<p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000号的哈希槽。</p>
<p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p>
<p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p>
<h1 id="Redis一致性保证"><a href="#Redis一致性保证" class="headerlink" title="Redis一致性保证"></a>Redis一致性保证</h1><p>Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：<br>第一个原因是因为集群是用了异步复制. 写操作过程:</p>
<ol>
<li>客户端向主节点B写入一条命令.</li>
<li>主节点B向客户端回复命令状态.</li>
<li>主节点将写操作复制给他得从节点 B1, B2 和 B3</li>
</ol>
<p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。<br>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .<br>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.<br>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项</p>
<h1 id="搭建Redis集群"><a href="#搭建Redis集群" class="headerlink" title="搭建Redis集群"></a>搭建Redis集群</h1><p>要让集群正常工作至少需要3个主节点，在这里我们要创建6个redis节点，其中三个为主节点，三个为从节点，对应的redis节点的ip和端口对应关系如下（为了简单演示都在同一台机器上面）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:7000</div><div class="line"></div><div class="line">127.0.0.1:7001</div><div class="line"></div><div class="line">127.0.0.1:7002</div><div class="line"></div><div class="line">127.0.0.1:7003</div><div class="line"></div><div class="line">127.0.0.1:7004</div><div class="line"></div><div class="line">127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<h2 id="安装和启动Redis"><a href="#安装和启动Redis" class="headerlink" title="安装和启动Redis"></a>安装和启动Redis</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-3.2.9.tar.gz</div></pre></td></tr></table></figure>
<h3 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar zxvf redis-3.2.9.tar.gz</div><div class="line">cd redis-3.2.9</div><div class="line">make &amp;&amp; make PREFIX=/usr/local/redis install</div></pre></td></tr></table></figure>
<p>  这里如果失败的自行yum安装gcc和tcl<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install gcc</div><div class="line">yum install tcl</div></pre></td></tr></table></figure></p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/redis</div><div class="line">mkdir cluster</div><div class="line">cd cluster</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure>
<h3 id="复制和修改配置文件"><a href="#复制和修改配置文件" class="headerlink" title="复制和修改配置文件"></a>复制和修改配置文件</h3><p>将redis目录下的配置文件复制到对应端口文件夹下,6个文件夹都要复制一份<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp redis-3.2.9/redis.conf /usr/local/redis/cluster/7000</div></pre></td></tr></table></figure></p>
<p>修改配置文件<code>redis.conf</code>，将下面的选项修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># 端口号</div><div class="line">port 7000</div><div class="line"># 后台启动</div><div class="line">daemonize yes</div><div class="line"># 开启集群</div><div class="line">cluster-enabled yes</div><div class="line">#集群节点配置文件</div><div class="line">cluster-config-file nodes-7000.conf</div><div class="line"># 集群连接超时时间</div><div class="line">cluster-node-timeout 5000</div><div class="line"># 进程pid的文件位置</div><div class="line">pidfile /var/run/redis-7000.pid</div><div class="line"># 开启aof</div><div class="line">appendonly yes</div><div class="line"># aof文件路径</div><div class="line">appendfilename &quot;appendonly-7005.aof&quot;</div><div class="line"># rdb文件路径</div><div class="line">dbfilename dump-7000.rdb</div></pre></td></tr></table></figure></p>
<p>6个配置文件安装对应的端口分别修改配置文件</p>
<h3 id="创建启动脚本"><a href="#创建启动脚本" class="headerlink" title="创建启动脚本"></a>创建启动脚本</h3><p>在<code>/usr/local/redis</code>目录下创建一个start.sh<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line">bin/redis-server cluster/7000/redis.conf</div><div class="line">bin/redis-server cluster/7001/redis.conf</div><div class="line">bin/redis-server cluster/7002/redis.conf</div><div class="line">bin/redis-server cluster/7003/redis.conf</div><div class="line">bin/redis-server cluster/7004/redis.conf</div><div class="line">bin/redis-server cluster/7005/redis.conf</div></pre></td></tr></table></figure></p>
<p>这个时候我们查看一下进程看启动情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep redis</div></pre></td></tr></table></figure></p>
<p>进程状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root      1731     1  1 18:21 ?        00:00:49 bin/redis-server *:7000 [cluster]       </div><div class="line">root      1733     1  0 18:21 ?        00:00:29 bin/redis-server *:7001 [cluster]       </div><div class="line">root      1735     1  0 18:21 ?        00:00:08 bin/redis-server *:7002 [cluster]       </div><div class="line">root      1743     1  0 18:21 ?        00:00:26 bin/redis-server *:7003 [cluster]       </div><div class="line">root      1745     1  0 18:21 ?        00:00:13 bin/redis-server *:7004 [cluster]       </div><div class="line">root      1749     1  0 18:21 ?        00:00:08 bin/redis-server *:7005 [cluster]</div></pre></td></tr></table></figure></p>
<p>有6个redis进程在开启，说明我们的redis就启动成功了</p>
<h2 id="开启集群"><a href="#开启集群" class="headerlink" title="开启集群"></a>开启集群</h2><p>这里我们只是开启了6个redis进程而已，它们都还只是独立的状态，还么有组成集群<br>这里我们使用官方提供的工具redis-trib，不过这个工具是用ruby写的，要先安装ruby的环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install ruby rubygems -y</div></pre></td></tr></table></figure></p>
<p>执行，报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@centos]# redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div><div class="line">/usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `gem_original_require&apos;: no such file to load -- redis (LoadError)</div><div class="line">    from /usr/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:31:in `require&apos;</div><div class="line">    from /usr/local/bin/redis-trib.rb:25</div><div class="line">[root@centos]#</div></pre></td></tr></table></figure></p>
<p>原来是ruby和redis的连接没安装好<br>安装gem-redis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install redis</div></pre></td></tr></table></figure></p>
<p>安装到这里的时候突然卡住很久不动，网上搜了下，这里需要翻墙或者换镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem source -a https://gems.ruby-china.org</div></pre></td></tr></table></figure></p>
<p>这里可以将镜像换成ruby-china的镜像，不过我好像更换失败，最终还是翻墙下载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@centos]# gem install redis</div><div class="line">Successfully installed redis-3.2.1</div><div class="line">1 gem installed</div><div class="line">Installing ri documentation for redis-3.2.1...</div><div class="line">Installing RDoc documentation for redis-3.2.1...</div></pre></td></tr></table></figure></p>
<p>等下载好后我们就可以使用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@centos]# gem install redis</div><div class="line">Successfully installed redis-3.2.1</div><div class="line">1 gem installed</div><div class="line">Installing ri documentation for redis-3.2.1...</div><div class="line">Installing RDoc documentation for redis-3.2.1...</div></pre></td></tr></table></figure></p>
<p>将redis-3.2.9的src目录下的trib复制到相应文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp redis-3.2.9/src/redis-trib.rb /usr/local/redis/bin/redis-trib</div></pre></td></tr></table></figure></p>
<p>创建集群：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-trib create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</div></pre></td></tr></table></figure></p>
<p>命令的意义如下：</p>
<ul>
<li>给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。</li>
<li>选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。<br>简单来说，以上的命令的意思就是让redis-trib程序帮我们创建三个主节点和三个从节点的集群<br>接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; Creating cluster</div><div class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</div><div class="line">Using 3 masters:</div><div class="line">127.0.0.1:7000</div><div class="line">127.0.0.1:7001</div><div class="line">127.0.0.1:7002</div><div class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000</div><div class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7001</div><div class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</div><div class="line">M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446a</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</div></pre></td></tr></table></figure>
<p>按下yes，集群就会将配置应用到各个节点，并连接起（join)各个节点，也即是，让各个节点开始通讯<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; Nodes configuration updated</div><div class="line">&gt;&gt;&gt; Assign a different config epoch to each node</div><div class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</div><div class="line">Waiting for the cluster to join...</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446a</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<h1 id="Redis集群的使用"><a href="#Redis集群的使用" class="headerlink" title="Redis集群的使用"></a>Redis集群的使用</h1><h2 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h2><p>这里我们使用reids-cli连接集群，使用时加上<code>-c</code>参数，就可以连接到集群<br>连接7000端口的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@centos1 redis]# ./redis-cli -c -p 7000</div><div class="line">127.0.0.1:7000&gt; set name zgj</div><div class="line">-&gt; Redirected to slot [5798] located at 127.0.0.1:7001</div><div class="line">OK</div><div class="line">127.0.0.1:7001&gt; get name</div><div class="line">&quot;zgj&quot;</div></pre></td></tr></table></figure></p>
<p>前面的理论知识我们知道了，分配key的时候，它会使用<code>CRC16</code>算法，这里将key<code>name</code>分配到了7001节点上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Redirected to slot [5798] located at 127.0.0.1:7001</div></pre></td></tr></table></figure>
<p>redis cluster 采用的方式很直接，它直接跳转到7001 节点了，而不是还在自身的7000节点。</p>
<p>好，现在我们连接7003这个从节点进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@centos1 redis]# ./redis-cli -c -p 7003</div><div class="line">127.0.0.1:7003&gt; get name</div><div class="line">-&gt; Redirected to slot [5798] located at 127.0.0.1:7001</div><div class="line">&quot;zgj&quot;</div></pre></td></tr></table></figure></p>
<p>这里获取<code>name</code>的值，也同样跳转到了7001上<br>我们再测试一下其他数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:7001&gt; set age 20</div><div class="line">-&gt; Redirected to slot [741] located at 127.0.0.1:7000</div><div class="line">OK</div><div class="line">127.0.0.1:7000&gt; set message helloworld</div><div class="line">-&gt; Redirected to slot [11537] located at 127.0.0.1:7002</div><div class="line">OK</div><div class="line">127.0.0.1:7002&gt; set height 175</div><div class="line">-&gt; Redirected to slot [8223] located at 127.0.0.1:7001</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>我们发现数据会在7000-7002这3个节点之间来回跳转</p>
<h2 id="测试集群中的节点挂掉"><a href="#测试集群中的节点挂掉" class="headerlink" title="测试集群中的节点挂掉"></a>测试集群中的节点挂掉</h2><p>上面我们建立了一个集群，3个主节点和3个从节点，7000-7002负责存取数据，7003-7005负责把7000-7005的数据同步到自己的节点上来。<br>我们现在来模拟一下一台matser服务器宕机的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">[root@centos1 redis]# ps -ef | grep redis</div><div class="line">root      1731     1  0 18:21 ?        00:01:02 bin/redis-server *:7000 [cluster]       </div><div class="line">root      1733     1  0 18:21 ?        00:00:43 bin/redis-server *:7001 [cluster]       </div><div class="line">root      1735     1  0 18:21 ?        00:00:22 bin/redis-server *:7002 [cluster]       </div><div class="line">root      1743     1  0 18:21 ?        00:00:40 bin/redis-server *:7003 [cluster]       </div><div class="line">root      1745     1  0 18:21 ?        00:00:27 bin/redis-server *:7004 [cluster]       </div><div class="line">root      1749     1  0 18:21 ?        00:00:22 bin/redis-server *:7005 [cluster]       </div><div class="line">root     23988     1  0 18:30 ?        00:00:42 ./redis-server *:6379    </div><div class="line">root     24491  1635  0 21:55 pts/1    00:00:00 grep redis</div><div class="line">[root@centos1 redis]# kill 1731</div><div class="line">[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7001</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">M: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure>
<p>这里看得出来，现在已经有了3个节点了，7003被选取成了替代7000成为主节点了。<br>我们再来模拟 7000节点重新启动了的情况，那么它还会自动加入到集群中吗？那么，7000这个节点上充当什么角色呢？ 我们试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[root@centos1 redis]# bin/redis-server cluster/7000/redis.conf</div><div class="line">[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7000</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">S: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates d403713ab9db48aeac5b5393b69e1201026ef479</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到7000节点变成了7003节点的从节点<br>我们试着将7000和7003两个节点都关掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[root@centos1 redis]# ps -ef | grep redis</div><div class="line">root      1733     1  0 18:21 ?        00:00:45 bin/redis-server *:7001 [cluster]       </div><div class="line">root      1735     1  0 18:21 ?        00:00:24 bin/redis-server *:7002 [cluster]       </div><div class="line">root      1743     1  0 18:21 ?        00:00:42 bin/redis-server *:7003 [cluster]       </div><div class="line">root      1745     1  0 18:21 ?        00:00:29 bin/redis-server *:7004 [cluster]       </div><div class="line">root      1749     1  0 18:21 ?        00:00:24 bin/redis-server *:7005 [cluster]       </div><div class="line">root     23988     1  0 18:30 ?        00:00:43 ./redis-server *:6379    </div><div class="line">root     24527     1  0 22:04 ?        00:00:00 bin/redis-server *:7000 [cluster]       </div><div class="line">root     24541  1635  0 22:07 pts/1    00:00:00 grep redis</div><div class="line">[root@centos1 redis] kill 1743</div><div class="line">[root@centos1 redis] kill 24527</div><div class="line"></div><div class="line">[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7001</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[ERR] Not all 16384 slots are covered by nodes.</div></pre></td></tr></table></figure>
<p>这里我们的集群就不能工作了，因为两个节点主节点和从节点都挂掉了，原来7001分配的slot现在无节点接管，需要人工介入重新分配slots。</p>
<h2 id="集群中加入新的主节点"><a href="#集群中加入新的主节点" class="headerlink" title="集群中加入新的主节点"></a>集群中加入新的主节点</h2><p>这里在cluster目录下再新建一个7006并修改对应的配置文件，然后启动这个这个redis进程<br>然后再使用redis-trib的<code>add node</code>指令加入节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>这里前面的节点表示要加入的节点，第二个节点表示要加入的集群中的任意一个节点，用来标识这个集群<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">[root@centos1 redis]# bin/redis-trib add-node 127.0.0.1:7006 127.0.0.1:7000</div><div class="line">&gt;&gt;&gt; Adding node 127.0.0.1:7006 to cluster 127.0.0.1:7000</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446a</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7006 to make it join the cluster.</div><div class="line">[OK] New node added correctly.</div><div class="line">[root@centos1 redis]# bin/redis-trib check 127.0.0.1:7006</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446a</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006</div><div class="line">   slots: (0 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到7006节点已经变成了一个主节点，然鹅，等等，好像发现了有什么地方不对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006</div><div class="line">   slots: (0 slots) master</div></pre></td></tr></table></figure></p>
<p>里面<code>0 slots</code>,也就是说节点6没有分配哈希槽，即不能进行数据的存取，拿我加上去干嘛。。<br>原来redis cluster 不是在新加节点的时候帮我们做好了迁移工作，需要我们手动对集群进行重新分片迁移，也是这个命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/redis-trib reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>这个命令是用来迁移slot节点的，后面的127.0.0.1:7000是表示哪个集群的，7000-7006都是可以的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">[root@centos1]# redis-trib.rb reshard 127.0.0.1:7000</div><div class="line">Connecting to node 127.0.0.1:7006: OK</div><div class="line">Connecting to node 127.0.0.1:7001: OK</div><div class="line">Connecting to node 127.0.0.1:7004: OK</div><div class="line">Connecting to node 127.0.0.1:7000: OK</div><div class="line">Connecting to node 127.0.0.1:7002: OK</div><div class="line">Connecting to node 127.0.0.1:7005: OK</div><div class="line">Connecting to node 127.0.0.1:7003: OK</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7006)</div><div class="line">M: efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006</div><div class="line">   slots: (0 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c</div><div class="line">S: 3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">M: dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates dfa0754c7854a874a6ebd2613b86140ad97701fc</div><div class="line">M: d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line">How many slots do you want to move (from 1 to 16384)?</div></pre></td></tr></table></figure></p>
<p>它提示我们需要迁移多少slot到7006上，我们可以算一下：16384/4 = 4096，也就是说，为了平衡分配起见，我们需要移动4096个槽点到7006上。</p>
<p>好，那输入4096:<br>它又提示我们，接受的node ID是多少，7006的id 我们通过上面就可以看到是<code>efc3131fbdc6cf929720e0e0f7136cae85657481</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">What is the receiving node ID? efc3131fbdc6cf929720e0e0f7136cae85657481</div><div class="line">Please enter all the source node IDs.</div><div class="line">  Type &apos;all&apos; to use all the nodes as source nodes for the hash slots.</div><div class="line">  Type &apos;done&apos; once you entered all the source nodes IDs.</div><div class="line">Source node #1:</div></pre></td></tr></table></figure></p>
<p>接着， redis-trib 会向你询问重新分片的源节点（source node）， 也即是， 要从哪个节点中取出 4096 个哈希槽， 并将这些槽移动到7006节点上面。</p>
<p>如果我们不打算从特定的节点上取出指定数量的哈希槽， 那么可以向 redis-trib 输入 all ， 这样的话， 集群中的所有主节点都会成为源节点， redis-trib 将从各个源节点中各取出一部分哈希槽， 凑够 4096 个， 然后移动到7006节点上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Source node #1:all</div></pre></td></tr></table></figure></p>
<p>接下来就开始迁移了，并且会询问你是否确认：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Moving slot 1359 from d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">    Moving slot 1360 from d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">    Moving slot 1361 from d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">    Moving slot 1362 from d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">    Moving slot 1363 from d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">    Moving slot 1364 from d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">Do you want to proceed with the proposed reshard plan (yes/no)?</div></pre></td></tr></table></figure></p>
<p>输入yes并回车后，redis-trib就会正式执行重新分片操作，将制定的哈希槽从源节点一个个移动到7006节点上<br>迁移结束之后，我们来检查一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">M: bdcddddd3d78a866b44b68c7ae0e5ccf875c446a 127.0.0.1:7000</div><div class="line">   slots:1365-5460 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d403713ab9db48aeac5b5393b69e1201026ef479 127.0.0.1:7003</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates bdcddddd3d78a866b44b68c7ae0e5ccf875c446a</div><div class="line">S: b7ec92919e5bcffa76c8eee338f8ca5155293c64 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b85519795fa42aa33d4e88d25104cbae895933a6</div><div class="line">M: e55599320dabfb31bd22a01407e66121f075e7d3 127.0.0.1:7006</div><div class="line">   slots:0-1364,5461-6826,10923-12287 (4096 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: b85519795fa42aa33d4e88d25104cbae895933a6 127.0.0.1:7001</div><div class="line">   slots:6827-10922 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 8a0d2a3f271b349744a971e1b0a545405de2742e 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b681e1a151890cbf957d1ff08352ee48f6ae39e6</div><div class="line">M: b681e1a151890cbf957d1ff08352ee48f6ae39e6 127.0.0.1:7002</div><div class="line">   slots:12288-16383 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>我们可以看到<br><code>slots:0-1364,5461-6826,10923-12287 (4096 slots)</code><br>这些原来在其他节点上的哈希槽都迁移到了7006上</p>
<h2 id="增加一个从节点"><a href="#增加一个从节点" class="headerlink" title="增加一个从节点"></a>增加一个从节点</h2><p>新建一个 7007从节点，作为7006的从节点</p>
<p>我们再新建一个节点7007，步骤类似，就先省略了。建好后，启动起来，我们看如何把它加入到集群中的从节点中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@centos1]# redis-trib.rb add-node --slave 127.0.0.1:7007 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>add-node的时候加上<code>--slave</code>表示是加入到从节点中，但是这样加，是随机的。这里的命令行完全像我们在添加一个新主服务器时使用的一样，所以我们没有指定要给哪个主服 务器添加副本。这种情况下，redis-trib会将7007作为一个具有较少副本的随机的主服务器的副本。</p>
<p>那么，你猜，它会作为谁的从节点，应该是7006，因为7006还没有从节点。我们运行下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@web3 7007]# redis-trib.rb add-node --slave 127.0.0.1:7007 127.0.0.1:7000</div><div class="line">...</div><div class="line">...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line">Automatically selected master 127.0.0.1:7006</div><div class="line">Connecting to node 127.0.0.1:7007: OK</div><div class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7007 to make it join the cluster.</div><div class="line">Waiting for the cluster to join.</div><div class="line">&gt;&gt;&gt; Configure node as replica of 127.0.0.1:7006.</div><div class="line">[OK] New node added correctly.</div></pre></td></tr></table></figure></p>
<p>上面提示说，自动选择了7006作为master节点。并且成功了。我们检查下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">[root@centos1]# redis-trib.rb check 127.0.0.1:7000</div><div class="line">Connecting to node 127.0.0.1:7000: OK</div><div class="line">Connecting to node 127.0.0.1:7006: OK</div><div class="line">Connecting to node 127.0.0.1:7004: OK</div><div class="line">Connecting to node 127.0.0.1:7005: OK</div><div class="line">Connecting to node 127.0.0.1:7003: OK</div><div class="line">Connecting to node 127.0.0.1:7001: OK</div><div class="line">Connecting to node 127.0.0.1:7007: OK</div><div class="line">Connecting to node 127.0.0.1:7002: OK</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</div><div class="line">S: 3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates d2237fdcfbba672de766b913d1186cebcb6e1761</div><div class="line">M: efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006</div><div class="line">   slots:0-1364,5461-6826,10923-12287 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c</div><div class="line">S: 30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates dfa0754c7854a874a6ebd2613b86140ad97701fc</div><div class="line">M: d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003</div><div class="line">   slots:1365-5460 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001</div><div class="line">   slots:6827-10922 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates efc3131fbdc6cf929720e0e0f7136cae85657481</div><div class="line">M: dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002</div><div class="line">   slots:12288-16383 (4096 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check for open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>果然，7007加入到了7006的从节点当中。</p>
<p>你说，我如果想指定一个主节点行不行？当然可以。我们再建一个7008节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/redis-trib.rb add-node --slave --master-id efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7008 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p><code>--master-id</code> 表示指定的主节点node id。这里指定的是 7006 这个主节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Waiting for the cluster to join.</div><div class="line">&gt;&gt;&gt; Configure node as replica of 127.0.0.1:7006.</div><div class="line">[OK] New node added correctly.</div></pre></td></tr></table></figure></p>
<p>提示我们已经作为7006的从节点了，也就是加入到7006的从节点来了，照这么说，7006就有2个从节点了，我们看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bin/redis-cli -c -p 7008 cluster nodes |grep efc3131fbdc6cf929720e0e0f7136cae85657481</div><div class="line">86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 slave efc3131fbdc6cf929720e0e0f7136cae85657481 0 1445089507786 8 connected</div><div class="line">efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 master - 0 1445089508289 8 connected 0-1364 5461-6826 10923-12287</div><div class="line">44321e7d619410dc4e0a8745366610a0d06d2395 127.0.0.1:7008 myself,slave efc3131fbdc6cf929720e0e0f7136cae85657481 0 0 0 connected</div></pre></td></tr></table></figure></p>
<p>我们过滤了下看结果，果真，7007和7008是7006的从节点了。</p>
<p>刚好，我们再做一个实验，我把7006的进程杀掉，看7007和7008谁会变成主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[root@centos1]# ps -ef|grep redis</div><div class="line">root     11384     1  0 09:56 ?        00:00:16 redis-server *:7001 [cluster]</div><div class="line">root     11388     1  0 09:56 ?        00:00:16 redis-server *:7002 [cluster]</div><div class="line">root     11392     1  0 09:56 ?        00:00:16 redis-server *:7003 [cluster]</div><div class="line">root     11396     1  0 09:56 ?        00:00:15 redis-server *:7004 [cluster]</div><div class="line">root     11400     1  0 09:56 ?        00:00:15 redis-server *:7005 [cluster]</div><div class="line">root     12100     1  0 11:01 ?        00:00:11 redis-server *:7000 [cluster]</div><div class="line">root     12132     1  0 11:28 ?        00:00:11 redis-server *:7006 [cluster]</div><div class="line">root     12202     1  0 13:14 ?        00:00:02 redis-server *:7007 [cluster]</div><div class="line">root     12219     1  0 13:39 ?        00:00:00 redis-server *:7008 [cluster]</div><div class="line">root     12239  8259  0 13:49 pts/0    00:00:00 grep redis</div><div class="line">[root@centos1]# kill 12132</div><div class="line">[root@centos1]# redis-cli -c -p 7008</div><div class="line">127.0.0.1:7008&gt; get ss5rtr</div><div class="line">-&gt; Redirected to slot [1188] located at 127.0.0.1:7007</div><div class="line">&quot;66&quot;</div><div class="line">127.0.0.1:7007&gt; cluster nodes</div><div class="line">efc3131fbdc6cf929720e0e0f7136cae85657481 127.0.0.1:7006 master,fail - 1445089780668 1445089779963 8 disconnected</div><div class="line">d2237fdcfbba672de766b913d1186cebcb6e1761 127.0.0.1:7003 master - 0 1445089812195 7 connected 1365-5460</div><div class="line">30858dbf483b61b9838d5c1f853a60beaa4e7afd 127.0.0.1:7005 slave dfa0754c7854a874a6ebd2613b86140ad97701fc 0 1445089813710 3 connected</div><div class="line">86d05e7c2b197dc182b5e71069e791d033cf899e 127.0.0.1:7007 myself,master - 0 0 10 connected 0-1364 5461-6826 10923-12287</div><div class="line">cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 127.0.0.1:7001 master - 0 1445089814214 2 connected 6827-10922</div><div class="line">4b4aef8b48c427a3c903518339d53b6447c58b93 127.0.0.1:7004 slave cb5c04b6160c3b7e18cad5d49d8e2987b27e0d6c 0 1445089812701 2 connected</div><div class="line">44321e7d619410dc4e0a8745366610a0d06d2395 127.0.0.1:7008 slave 86d05e7c2b197dc182b5e71069e791d033cf899e 0 1445089814214 10 connected</div><div class="line">3707debcbe7be66d4a1968eaf3a5ffaf4308efa4 127.0.0.1:7000 slave d2237fdcfbba672de766b913d1186cebcb6e1761 0 1445089813204 7 connected</div><div class="line">dfa0754c7854a874a6ebd2613b86140ad97701fc 127.0.0.1:7002 master - 0 1445089813204 3 connected 12288-16383</div><div class="line">127.0.0.1:7007&gt;</div></pre></td></tr></table></figure></p>
<p>这里7007获得了成为主节点的机会，7008就变成了7007的从节点。</p>
<p>那么这个时候，重启7006节点，那么他就会变成了一个7007的从节点了。</p>
<h2 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h2><p>上面是增加一个节点，接下来就是移除一个节点了，移除节点的命令是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/redis-trib del-node 127.0.0.1:7000 `&lt;node-id&gt;`</div></pre></td></tr></table></figure></p>
<p>没我们尝试下输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@centos]# bin/redis-trib.rb del-node 127.0.0.1:7000 86d05e7c2b197dc182b5e71069e791d033cf899e</div><div class="line">&gt;&gt;&gt; Removing node 86d05e7c2b197dc182b5e71069e791d033cf899e from cluster 127.0.0.1:7000</div><div class="line">Connecting to node 127.0.0.1:7000: OK</div><div class="line">Connecting to node 127.0.0.1:7006: OK</div><div class="line">Connecting to node 127.0.0.1:7004: OK</div><div class="line">Connecting to node 127.0.0.1:7001: OK</div><div class="line">Connecting to node 127.0.0.1:7003: OK</div><div class="line">Connecting to node 127.0.0.1:7007: OK</div><div class="line">Connecting to node 127.0.0.1:7008: OK</div><div class="line">Connecting to node 127.0.0.1:7005: OK</div><div class="line">Connecting to node 127.0.0.1:7002: OK</div><div class="line">[ERR] Node 127.0.0.1:7007 is not empty! Reshard data away and try again.</div></pre></td></tr></table></figure></p>
<p>这里报错了，提示我们7007节点里面有数据，让我们把7007节点里的数据移除出去，也就是说需要重新分片，这个和上面增加节点的方式一样，我们再来一遍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/redis-trib.rb reshard 127.0.0.1:7000</div></pre></td></tr></table></figure></p>
<p>省去中间内容，原来7007节点上已经有了4096个哈希槽，这里我们也移动4096个哈希槽<br>然后将这些哈希槽移动到7001节点上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Source node #1:86d05e7c2b197dc182b5e71069e791d033cf899e</div><div class="line">Source node #2:done</div><div class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</div></pre></td></tr></table></figure></p>
<p>然后我们再继续执行移除命令，结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@centos1]# redis-trib.rb del-node 127.0.0.1:7000 86d05e7c2b197dc182b5e71069e791d033cf899e</div><div class="line">&gt;&gt;&gt; Removing node 86d05e7c2b197dc182b5e71069e791d033cf899e from cluster 127.0.0.1:7000</div><div class="line">Connecting to node 127.0.0.1:7000: OK</div><div class="line">Connecting to node 127.0.0.1:7006: OK</div><div class="line">Connecting to node 127.0.0.1:7004: OK</div><div class="line">Connecting to node 127.0.0.1:7001: OK</div><div class="line">Connecting to node 127.0.0.1:7003: OK</div><div class="line">Connecting to node 127.0.0.1:7007: OK</div><div class="line">Connecting to node 127.0.0.1:7008: OK</div><div class="line">Connecting to node 127.0.0.1:7005: OK</div><div class="line">Connecting to node 127.0.0.1:7002: OK</div><div class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</div><div class="line">&gt;&gt;&gt; 127.0.0.1:7006 as replica of 127.0.0.1:7001</div><div class="line">&gt;&gt;&gt; 127.0.0.1:7008 as replica of 127.0.0.1:7001</div><div class="line">&gt;&gt;&gt; SHUTDOWN the node.</div></pre></td></tr></table></figure></p>
<p>删除成功，而且还很人性化的将7006和7008这2个原来7007的附属节点送给了7001。考虑的真周到~</p>
<h2 id="移除一个从节点"><a href="#移除一个从节点" class="headerlink" title="移除一个从节点"></a>移除一个从节点</h2><p>移除一个从节点就比较简单了，因为从节点没有哈希槽，也不需要考虑数据迁移，直接移除就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@centos1]# redis-trib.rb del-node 127.0.0.1:7005 44321e7d619410dc4e0a8745366610a0d06d2395</div><div class="line">&gt;&gt;&gt; Removing node 44321e7d619410dc4e0a8745366610a0d06d2395 from cluster 127.0.0.1:7005</div><div class="line">Connecting to node 127.0.0.1:7005: OK</div><div class="line">Connecting to node 127.0.0.1:7001: OK</div><div class="line">Connecting to node 127.0.0.1:7002: OK</div><div class="line">Connecting to node 127.0.0.1:7004: OK</div><div class="line">Connecting to node 127.0.0.1:7000: OK</div><div class="line">Connecting to node 127.0.0.1:7006: OK</div><div class="line">Connecting to node 127.0.0.1:7008: OK</div><div class="line">Connecting to node 127.0.0.1:7003: OK</div><div class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</div><div class="line">&gt;&gt;&gt; SHUTDOWN the node.</div><div class="line">[root@centos1]# redis-trib.rb check 127.0.0.1:7008</div><div class="line">Connecting to node 127.0.0.1:7008: [ERR] Sorry, can&apos;t connect to node 127.0.0.1:7008</div></pre></td></tr></table></figure></p>
<p>表示移除成功</p>
<h1 id="Redis性能测试"><a href="#Redis性能测试" class="headerlink" title="Redis性能测试"></a>Redis性能测试</h1><p>Redis自带了性能测试工具<code>redis-benchmark</code><br>使用说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;]</div><div class="line"></div><div class="line"> -h &lt;hostname&gt;      Server hostname (default 127.0.0.1)</div><div class="line"> -p &lt;port&gt;          Server port (default 6379)</div><div class="line"> -s &lt;socket&gt;        Server socket (overrides host and port)</div><div class="line"> -c &lt;clients&gt;       Number of parallel connections (default 50)</div><div class="line"> -n &lt;requests&gt;      Total number of requests (default 10000)</div><div class="line"> -d &lt;size&gt;          Data size of SET/GET value in bytes (default 2)</div><div class="line"> -k &lt;boolean&gt;       1=keep alive 0=reconnect (default 1)</div><div class="line"> -r &lt;keyspacelen&gt;   Use random keys for SET/GET/INCR, random values for SADD</div><div class="line">  Using this option the benchmark will get/set keys</div><div class="line">  in the form mykey_rand:000000012456 instead of constant</div><div class="line">  keys, the &lt;keyspacelen&gt; argument determines the max</div><div class="line">  number of values for the random number. For instance</div><div class="line">  if set to 10 only rand:000000000000 - rand:000000000009</div><div class="line">  range will be allowed.</div><div class="line"> -P &lt;numreq&gt;        Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).</div><div class="line"> -q                 Quiet. Just show query/sec values</div><div class="line"> --csv              Output in CSV format</div><div class="line"> -l                 Loop. Run the tests forever</div><div class="line"> -t &lt;tests&gt;         Only run the comma-separated list of tests. The test</div><div class="line">                    names are the same as the ones produced as output.</div><div class="line"> -I                 Idle mode. Just open N idle connections and wait.</div></pre></td></tr></table></figure></p>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>基准的测试命令：<br><code>redis-benchmark -q -n 100000</code><br>结果入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">root@centos1 bin]# redis-benchmark -q -n 100000</div><div class="line">-bash: redis-benchmark: command not found</div><div class="line">[root@centos1 bin]# ./redis-benchmark -q -n 100000</div><div class="line">PING_INLINE: 61576.36 requests per second</div><div class="line">PING_BULK: 60277.28 requests per second</div><div class="line">SET: 61349.69 requests per second</div><div class="line">GET: 60459.49 requests per second</div><div class="line">INCR: 58858.15 requests per second</div><div class="line">LPUSH: 59066.75 requests per second</div><div class="line">RPUSH: 57339.45 requests per second</div><div class="line">LPOP: 55586.44 requests per second</div><div class="line">RPOP: 56465.27 requests per second</div><div class="line">SADD: 57045.07 requests per second</div><div class="line">SPOP: 53734.55 requests per second</div><div class="line">LPUSH (needed to benchmark LRANGE): 57012.54 requests per second</div><div class="line">LRANGE_100 (first 100 elements): 55803.57 requests per second</div><div class="line">LRANGE_300 (first 300 elements): 54914.88 requests per second</div><div class="line">LRANGE_500 (first 450 elements): 53333.33 requests per second</div><div class="line">LRANGE_600 (first 600 elements): 56529.11 requests per second</div><div class="line">MSET (10 keys): 59276.82 requests per second</div></pre></td></tr></table></figure></p>
<p>这里可以看出，单机版的redis每秒可以处理6万个请求，这已经是一个非常高的并发量了<br>我们再来看下集群情况下是是什么情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[root@centos1 bin]# ./redis-benchmark -q -n 100000 -p 7000</div><div class="line">PING_INLINE: 64599.48 requests per second</div><div class="line">PING_BULK: 64184.85 requests per second</div><div class="line">SET: 66800.27 requests per second</div><div class="line">GET: 65616.80 requests per second</div><div class="line">INCR: 66269.05 requests per second</div><div class="line">LPUSH: 40273.86 requests per second</div><div class="line">RPUSH: 40355.12 requests per second</div><div class="line">LPOP: 43421.62 requests per second</div><div class="line">RPOP: 45187.53 requests per second</div><div class="line">SADD: 62539.09 requests per second</div><div class="line">SPOP: 61538.46 requests per second</div><div class="line">LPUSH (needed to benchmark LRANGE): 38182.51 requests per second</div><div class="line">LRANGE_100 (first 100 elements): 25555.84 requests per second</div><div class="line">LRANGE_300 (first 300 elements): 9571.21 requests per second</div><div class="line">LRANGE_500 (first 450 elements): 7214.49 requests per second</div><div class="line">LRANGE_600 (first 600 elements): 5478.85 requests per second</div><div class="line">MSET (10 keys): 41893.59 requests per second</div></pre></td></tr></table></figure></p>
<p>这里看出大部分和单机版的性能查不多，主要是<code>lrange</code>命令的差别是很大的</p>
<h3 id="流水线测试"><a href="#流水线测试" class="headerlink" title="流水线测试"></a>流水线测试</h3><p>使用流水线<br>默认情况下，每个客户端都是在一个请求完成之后才发送下一个请求（基准会模拟50个客户端除非使用-c指定特别的数量），这意味着服务器几乎是按顺序读取每个客户端的命令。RTT也加入了其中。<br>真实世界会更复杂，Redis支持/topics/pipelining，使得可以一次性执行多条命令成为可能。Redis流水线可以提高服务器的TPS<br><code>redis-benchmark -n 1000000 -t set,get -P 16 -q</code> 加入-P选项使用管道技术，一次执行多条命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./redis-benchmark -n 1000000 -t set,get -P 16 -q</div><div class="line">SET: 515198.34 requests per second</div><div class="line">GET: 613873.56 requests per second</div></pre></td></tr></table></figure></p>
<p>每秒处理get/sret请求达到了60/50W,真的厉害！</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li>安装redis集群的时候遇到了挺多问题，踩了很多坑，单单是修改配置文件就出了不少问题，那些配置文件的内容都要一一修改，有些配置不修改就会出现无法创建进程的错误</li>
<li>注意配置集群的时候不要加密码，否则会出现无法连接的情况</li>
<li><code>gem install</code>的时候需要修改镜像或者翻墙</li>
<li>昨天启动成功，今天启动的时候报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ERR] Node 172.168.63.202:7001 is not empty. Either the nodealready knows other nodes (check with CLUSTER NODES) or contains some key in database 0</div></pre></td></tr></table></figure>
</li>
</ol>
<p>解决方法：<br>1). 将需要新增的节点下aof、rdb等本地备份文件删除；<br>2). 同时将新Node的集群配置文件删除,即：删除你<code>redis.conf</code>里面<code>cluster-config-file</code>所在的文件；<br>3). 再次添加新节点如果还是报错，则登录新Node,执行<code>bin/redis-cli–h x –p</code>对数据库进行清除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">173.172.168.63.201:7001&gt;  flushdb      #清空当前数据库</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之间对Redis的了解并不是说非常多，只是简单的会用，因为现在企业里也很多都在用，刚好老大说接下来的项目可能会用到Redis集群，让我先去了解下，所以最近就在回头看，一边看文档，博客，一边实践，踩了很多的坑，出问题的时候的确是让人感到很痛苦很郁闷的，可是当运行成功的那一刻心情却是无比激动和开心的，可能这就是编程的魅力吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Redis 是我们目前大规模使用的缓存中间件，由于它强大高效而又便捷的功能，得到了广泛的使用。单节点的Redis已经就达到了很高的性能，为了提高可用性我们可以使用Redis集群。本文参考了Rdis的官方文档和使用Redis官方提供的Redis Cluster工具搭建Rdis集群。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ：Redis的版本要在3.0以上,截止今天，Redis的版本是3.2.9，本教程也使用3.2.9作为教程&lt;br&gt;
    
    </summary>
    
      <category term="NoSQL" scheme="https://zgj12138.github.io/blog/categories/NoSQL/"/>
    
    
      <category term="redis" scheme="https://zgj12138.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者的五种实现方式</title>
    <link href="https://zgj12138.github.io/blog/2017/06/30/Java%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://zgj12138.github.io/blog/2017/06/30/Java生产者消费者模型的五种实现方式/</id>
    <published>2017-06-30T13:47:18.000Z</published>
    <updated>2017-08-08T16:07:17.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。<br><img src="https://ooo.0o0.ooo/2017/06/29/595523d4de338.png" alt="生产者消费者.png"><br><strong>现在用五种方式来实现生产者消费者模型</strong><br><a id="more"></a></p>
<h1 id="wait-和notify-方法的实现"><a href="#wait-和notify-方法的实现" class="headerlink" title="wait()和notify()方法的实现"></a>wait()和notify()方法的实现</h1><p>这也是最简单最基础的实现，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个产品或者消费者消费了一个产品之后会唤醒所有线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 生产者和消费者，wait()和notify()的实现</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年6月22日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Integer count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer FULL = <span class="number">10</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String LOCK = <span class="string">"lock"</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test1 test1 = <span class="keyword">new</span> Test1();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test1.new Consumer()).start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">synchronized</span> (LOCK) &#123;</div><div class="line">					<span class="keyword">while</span> (count == FULL) &#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							LOCK.wait();</div><div class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">							e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					count++;</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产，目前总共有"</span> + count);</div><div class="line">					LOCK.notifyAll();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">synchronized</span> (LOCK) &#123;</div><div class="line">					<span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							LOCK.wait();</div><div class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					count--;</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">"消费者消费，目前总共有"</span> + count);</div><div class="line">					LOCK.notifyAll();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>结果:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Thread-0生产者生产，目前总共有1</div><div class="line">Thread-4生产者生产，目前总共有2</div><div class="line">Thread-3消费者消费，目前总共有1</div><div class="line">Thread-1消费者消费，目前总共有0</div><div class="line">Thread-2生产者生产，目前总共有1</div><div class="line">Thread-6生产者生产，目前总共有2</div><div class="line">Thread-7消费者消费，目前总共有1</div><div class="line">Thread-5消费者消费，目前总共有0</div><div class="line">Thread-0生产者生产，目前总共有1</div><div class="line">Thread-4生产者生产，目前总共有2</div><div class="line">Thread-3消费者消费，目前总共有1</div><div class="line">Thread-6生产者生产，目前总共有2</div><div class="line">Thread-1消费者消费，目前总共有1</div><div class="line">Thread-7消费者消费，目前总共有0</div><div class="line">Thread-2生产者生产，目前总共有1</div><div class="line">Thread-5消费者消费，目前总共有0</div><div class="line">Thread-0生产者生产，目前总共有1</div><div class="line">Thread-4生产者生产，目前总共有2</div><div class="line">Thread-3消费者消费，目前总共有1</div><div class="line">Thread-7消费者消费，目前总共有0</div><div class="line">Thread-6生产者生产，目前总共有1</div><div class="line">Thread-2生产者生产，目前总共有2</div><div class="line">Thread-1消费者消费，目前总共有1</div><div class="line">Thread-5消费者消费，目前总共有0</div><div class="line">Thread-0生产者生产，目前总共有1</div><div class="line">Thread-4生产者生产，目前总共有2</div><div class="line">Thread-3消费者消费，目前总共有1</div><div class="line">Thread-1消费者消费，目前总共有0</div><div class="line">Thread-6生产者生产，目前总共有1</div><div class="line">Thread-7消费者消费，目前总共有0</div><div class="line">Thread-2生产者生产，目前总共有1</div></pre></td></tr></table></figure></p>
<h1 id="可重入锁ReentrantLock的实现"><a href="#可重入锁ReentrantLock的实现" class="headerlink" title="可重入锁ReentrantLock的实现"></a>可重入锁ReentrantLock的实现</h1><p>java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，通过对lock的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。<br>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 生产者和消费者，ReentrantLock的实现</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年6月22日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Integer count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer FULL = <span class="number">10</span>;</div><div class="line">	<span class="comment">//创建一个锁对象</span></div><div class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">	<span class="comment">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test2 test2 = <span class="keyword">new</span> Test2();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test2.new Consumer()).start();</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">                <span class="comment">//获取锁</span></div><div class="line">				lock.lock();</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="keyword">while</span> (count == FULL) &#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							notFull.await();</div><div class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">							e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					count++;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"生产者生产，目前总共有"</span> + count);</div><div class="line">					<span class="comment">//唤醒消费者</span></div><div class="line">					notEmpty.signal();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">                	<span class="comment">//释放锁</span></div><div class="line">					lock.unlock();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">					e1.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				lock.lock();</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">							notEmpty.await();</div><div class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">							e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">					count--;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"消费者消费，目前总共有"</span> + count);</div><div class="line">					notFull.signal();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					lock.unlock();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="阻塞队列BlockingQueue的实现"><a href="#阻塞队列BlockingQueue的实现" class="headerlink" title="阻塞队列BlockingQueue的实现"></a>阻塞队列BlockingQueue的实现</h1><p>BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。<br>被阻塞的情况主要有如下两种:</p>
<ol>
<li>当队列满了的时候进行入队列操作</li>
<li>当队列空了的时候进行出队列操作</li>
</ol>
<p>因此，当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。<br>从上可知，阻塞队列是线程安全的。<br>下面是BlockingQueue接口的一些方法:</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">抛异常</th>
<th style="text-align:center">特定值</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入</td>
<td style="text-align:center">add(o)</td>
<td style="text-align:center">offer(o)</td>
<td style="text-align:center">put(o)</td>
<td style="text-align:center">offer(o, timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:center">移除</td>
<td style="text-align:center">remove(o)</td>
<td style="text-align:center">poll(o)</td>
<td style="text-align:center">take(o)</td>
<td style="text-align:center">poll(timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:center">检查</td>
<td style="text-align:center">element(o)</td>
<td style="text-align:center">peek(o)</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>这四类方法分别对应的是：<br>1 . ThrowsException：如果操作不能马上进行，则抛出异常<br>2 . SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false<br>3 . Blocks:如果操作不能马上进行，操作会被阻塞<br>4 . TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false<br>下面来看由阻塞队列实现的生产者消费者模型,这里我们使用take()和put()方法，这里生产者和生产者，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用BlockingQueue实现生产者消费者模型</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年6月29日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Integer count = <span class="number">0</span>;</div><div class="line">	<span class="comment">//创建一个阻塞队列</span></div><div class="line">	<span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test3 test3 = <span class="keyword">new</span> Test3();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test3.new Consumer()).start();</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					blockingQueue.put(<span class="number">1</span>);</div><div class="line">					count++;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"生产者生产，目前总共有"</span> + count);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">					e1.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					blockingQueue.take();</div><div class="line">					count--;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"消费者消费，目前总共有"</span> + count);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="信号量Semaphore的实现"><a href="#信号量Semaphore的实现" class="headerlink" title="信号量Semaphore的实现"></a>信号量Semaphore的实现</h1><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。<br>在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用semaphore信号量实现</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年6月29日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Integer count = <span class="number">0</span>;</div><div class="line">	<span class="comment">//创建三个信号量</span></div><div class="line">	<span class="keyword">final</span> Semaphore notFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</div><div class="line">	<span class="keyword">final</span> Semaphore notEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line">	<span class="keyword">final</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test4 test4 = <span class="keyword">new</span> Test4();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Consumer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test4.new Consumer()).start();</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					notFull.acquire();</div><div class="line">					mutex.acquire();</div><div class="line">					count++;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"生产者生产，目前总共有"</span> + count);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					mutex.release();</div><div class="line">					notEmpty.release();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</div><div class="line">					e1.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					notEmpty.acquire();</div><div class="line">					mutex.acquire();</div><div class="line">					count--;</div><div class="line">					System.out.println(Thread.currentThread().getName()</div><div class="line">							+ <span class="string">"消费者消费，目前总共有"</span> + count);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					mutex.release();</div><div class="line">					notFull.release();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="管道输入输出流PipedInputStream和PipedOutputStream实现"><a href="#管道输入输出流PipedInputStream和PipedOutputStream实现" class="headerlink" title="管道输入输出流PipedInputStream和PipedOutputStream实现"></a>管道输入输出流PipedInputStream和PipedOutputStream实现</h1><p>在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用管道实现生产者消费者模型</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年6月30日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> PipedInputStream pis = <span class="keyword">new</span> PipedInputStream();</div><div class="line">	<span class="keyword">final</span> PipedOutputStream pos = <span class="keyword">new</span> PipedOutputStream();</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			pis.connect(pos);</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">					Thread.sleep(<span class="number">1000</span>);</div><div class="line">					<span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">255</span>);</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">"生产者生产了一个数字，该数字为： "</span> + num);</div><div class="line">					pos.write(num);</div><div class="line">					pos.flush();</div><div class="line">				&#125; </div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					pos.close();</div><div class="line">					pis.close();</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">					Thread.sleep(<span class="number">1000</span>);</div><div class="line">					<span class="keyword">int</span> num = pis.read();</div><div class="line">					System.out.println(<span class="string">"消费者消费了一个数字，该数字为："</span> + num);</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					pos.close();</div><div class="line">					pis.close();</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Test5 test5 = <span class="keyword">new</span> Test5();</div><div class="line">		<span class="keyword">new</span> Thread(test5.new Producer()).start();</div><div class="line">		<span class="keyword">new</span> Thread(test5.new Consumer()).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。&lt;br&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/29/595523d4de338.png&quot; alt=&quot;生产者消费者.png&quot;&gt;&lt;br&gt;&lt;strong&gt;现在用五种方式来实现生产者消费者模型&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zgj12138.github.io/blog/categories/Java/"/>
    
    
      <category term="并发" scheme="https://zgj12138.github.io/blog/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程" scheme="https://zgj12138.github.io/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之——单例模式</title>
    <link href="https://zgj12138.github.io/blog/2017/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zgj12138.github.io/blog/2017/05/19/设计模式之—单例模式/</id>
    <published>2017-05-19T13:47:18.000Z</published>
    <updated>2017-08-08T16:08:32.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。我们会理所当然的认为单例模式很简单，其实单例模式是事先方式有很多种，现在就来一一介绍一下。</p>
</blockquote>
<a id="more"></a>
<h1 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 构造函数私有化</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">			instance = <span class="keyword">new</span> Singleton();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种写法呢，有懒加载的作用，但是在多线程环境下会线程不安全<br>为什么会线程不安全呢？<br>我们假设一下，假如线程A和线程B同时调用<code>getInstance()</code>方法，线程A先执行判断<code>if(instance == null)</code>，判断instance对象是空的，这时候线程B获得了CPU执行权，它也判断instance对象是控制，这个时候执行了<code>instance = new Singleton();</code>这段代码，创建了一个对象并把这个对象的引用赋值给了instance，这个时候线程A又获得了执行权，之前已经判断过对象为空了，所以线程A又new了一个新的对象，这个时候就不符合单例模式的要求了，所以这种懒汉式是线程不安全的</p>
<h1 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，我们加上了synchronized关键字之后，相当于给这个对象加上了锁，就起到了同步的作用，同时只能有一个线程访问这个方法，不过这样的话也降低了效率</p>
<h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式基于classloder机制避免了多线程的同步问题，在类初始化的时候就实例化这个对象</p>
<h1 id="静态方法块"><a href="#静态方法块" class="headerlink" title="静态方法块"></a>静态方法块</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">	instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式和上一种区别不大，都是在类初始化即实例化instance对象</p>
<h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式同样利用了classloder的类加载机制来保证初始化instance时只有一个线程，它和第三种饿汉式，第四种静态方法块不同的是：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance</p>
<h1 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">	    <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">		<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">		    singleton = <span class="keyword">new</span> Singleton();</div><div class="line">		&#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>双重检查锁定在C语言或者其他语言中已被广泛当做多线程环境下延迟初始化的一种高效手段，但是在Java中并不能很好的实现，这个涉及到Java的内存模型，所以需要加上<code>volatile</code>关键字，这个关键字的作用是保证内存可见性和禁止指令重排序</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>枚举是JDK1.5之后才有的语法糖，实际上我们创建enum时，编译器会自动为我们生成一个继承自Java.lang.Enum的类<br>首先，在枚举中明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法，同时每个枚举实例都是static final类型的，也就表明只能被实例化一次。在调用构造方法时，我们的单例被实例化。<br>也就是说，因为enum中的实例被保证只会被实例化一次，所以我们的INSTANCE也被保证实例化一次。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。我们会理所当然的认为单例模式很简单，其实单例模式是事先方式有很多种，现在就来一一介绍一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zgj12138.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://zgj12138.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat配置</title>
    <link href="https://zgj12138.github.io/blog/2017/05/15/Tomcat%E9%85%8D%E7%BD%AE/"/>
    <id>https://zgj12138.github.io/blog/2017/05/15/Tomcat配置/</id>
    <published>2017-05-15T04:43:25.000Z</published>
    <updated>2017-08-30T15:59:50.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道Tomcat服务器是我们在学习JavaWeb中最常使用的服务器，所以了解Tomcat的配置文件显得很重要，昨天去面试的时候，被面试官问了几个关于Tomcat配置文件的几个问题， 以前配过，但是后来都忘记了，现在来回顾一下Tomcat中比较常用得到的配置文件吧</p>
<h1 id="配置文件的位置"><a href="#配置文件的位置" class="headerlink" title="配置文件的位置"></a>配置文件的位置</h1><p>Tomcat的配置文件在<code>conf</code>目录下，有<code>context.xml</code>、<code>server.xml</code>、<code>tomcat-users.xml</code>、<code>web.xml</code>这些配置文件</p>
<a id="more"></a>
<h1 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h1><h2 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h2><p>如果要修改连接的端口，在<code>server.xml</code>文件的<code>Server</code>标签和<code>Connectot</code>标签下修改<br>如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></div><div class="line">           <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></div><div class="line">           <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</div><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>将<code>port=xxxx</code>改成其他端口即可</p>
<h3 id="修改虚拟目录"><a href="#修改虚拟目录" class="headerlink" title="修改虚拟目录"></a>修改虚拟目录</h3><p>在<code>server.xml</code>中找到<code>Host</code>结点<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></div><div class="line">      <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- SingleSignOn valve, share authentication between web applications</span></div><div class="line">       Documentation at: /docs/config/valve.html --&gt;</div><div class="line">  <span class="comment">&lt;!--</span></div><div class="line">  &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;</div><div class="line">  --&gt;</div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- Access log processes all example.</span></div><div class="line">       Documentation at: /docs/config/valve.html</div><div class="line">       <span class="doctag">Note:</span> The pattern used is equivalent to using pattern="common" --&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></div><div class="line">         <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></div><div class="line">         <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>Host</code>结点代表一个主机，name对应的是其域名，我们可以通过修改name的属性来改变Tomcat资源的访问路径，方便我们管理</p>
<h2 id="tomcat-users"><a href="#tomcat-users" class="headerlink" title="tomcat-users"></a>tomcat-users</h2><p><code>toncat-users.xml</code>是配置用户登录Tomcat对app进行管理的配置文件，如果我们需要登录Tomcat，这需要在改配置文件的<code>tomcat-users</code>结点下加上如下代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   <span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-script"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"123456"</span>  <span class="attr">roles</span>=<span class="string">"manager-gui,manager-script"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中，我这里配置的登录名是utomcat,密码是123456<br>我们打开Tomcat主页，点击Manager App<br><img src="https://ooo.0o0.ooo/2017/05/15/59193c2fdc604.png" alt="tomcat.png"></p>
<p>输入用户名和密码，进入到管理界面</p>
<p><img src="https://ooo.0o0.ooo/2017/05/15/59193c2fd0af1.png" alt="tomcat-manager.png"><br>这个时候我们就可以对我们的app进行管理了</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们都知道Tomcat服务器是我们在学习JavaWeb中最常使用的服务器，所以了解Tomcat的配置文件显得很重要，昨天去面试的时候，被面试官问了几个关于Tomcat配置文件的几个问题， 以前配过，但是后来都忘记了，现在来回顾一下Tomcat中比较常用得到的配置文件吧&lt;/p&gt;
&lt;h1 id=&quot;配置文件的位置&quot;&gt;&lt;a href=&quot;#配置文件的位置&quot; class=&quot;headerlink&quot; title=&quot;配置文件的位置&quot;&gt;&lt;/a&gt;配置文件的位置&lt;/h1&gt;&lt;p&gt;Tomcat的配置文件在&lt;code&gt;conf&lt;/code&gt;目录下，有&lt;code&gt;context.xml&lt;/code&gt;、&lt;code&gt;server.xml&lt;/code&gt;、&lt;code&gt;tomcat-users.xml&lt;/code&gt;、&lt;code&gt;web.xml&lt;/code&gt;这些配置文件&lt;/p&gt;
    
    </summary>
    
      <category term="服务器" scheme="https://zgj12138.github.io/blog/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="tomcat" scheme="https://zgj12138.github.io/blog/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket 编程那些事（1）</title>
    <link href="https://zgj12138.github.io/blog/2017/05/02/Java%20Socket%20%E7%BC%96%E7%A8%8B%E9%82%A3%E4%BA%9B%E4%BA%8B(1)/"/>
    <id>https://zgj12138.github.io/blog/2017/05/02/Java Socket 编程那些事(1)/</id>
    <published>2017-05-02T15:47:44.000Z</published>
    <updated>2017-05-15T09:26:16.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>最近在准备面试和笔试的一些东西，回去翻看了Java关于IO的基础，发现很多基础还是没有记牢固，现在回头重新学习，就从socket通讯开始吧，虽然说现在企业很少直接编写socket，都是使用一些封装好的框架，netty,mina等。不过对于这些基础的知识，还是需要掌握牢固的，对于以后学习更深的框架和笔试面试都很有裨益。</p>
</blockquote>
<a id="more"></a>
<h2 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h2><p>Java中的IO的方式有三种<br><strong>Java BIO</strong> ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。在JDK1.4以前采用这种方式<br><strong>Java NIO</strong> ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br><strong>Java AIO(NIO.2)</strong> ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</p>
<p>曾经在一篇文章中看到这么很好的比喻</p>
<blockquote>
<p>如果你想吃一份宫保鸡丁盖饭：</p>
<p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！</p>
<p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！</p>
<p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。</p>
<p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p>
</blockquote>
<p>这里我们从最简单的BIO开始学习吧</p>
<h2 id="单线程通讯"><a href="#单线程通讯" class="headerlink" title="单线程通讯"></a>单线程通讯</h2><p>首先我们先新建一个Server类，这个类将监听12345这个端口，等待客户端的连接,客户端与服务器连接后，客户端可以像服务器发送信息，如果发送bye，则结束通讯<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.gduf.bio.socket.demo1;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 基于bio的socket服务器端</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年5月4日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//创建一个serversocket在10000号端口监听</span></div><div class="line">		<span class="keyword">try</span> (ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>)) &#123;</div><div class="line">			<span class="comment">//等待客户端连接，将一直阻塞直到有客户端连接</span></div><div class="line">		    Socket socket = server.accept();</div><div class="line">	        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">	        PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</div><div class="line"></div><div class="line">	        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">	            String msg = in.readLine();</div><div class="line">	            System.out.println(msg);</div><div class="line">	            out.println(<span class="string">"Server received "</span> + msg);</div><div class="line">	            out.flush();</div><div class="line">	            <span class="keyword">if</span> (msg.equals(<span class="string">"bye"</span>)) &#123;</div><div class="line">	                <span class="keyword">break</span>;</div><div class="line">	            &#125;</div><div class="line">	        &#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里<code>try (ServerSocket server = new ServerSocket(12345))</code>采用了java7的<code>try-with-resources</code>语法，这样写的好处是try里面声明的资源在最后都会自动关闭，而不需要我们手动关闭，简化了语法</p>
<p>Client类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.gduf.bio.socket.demo1;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 基于bio的socket客户端</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年5月4日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>)) &#123;</div><div class="line">			<span class="comment">//获取socket输入流</span></div><div class="line">			BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">			<span class="comment">//socket输出流</span></div><div class="line">			PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</div><div class="line">			<span class="comment">//标准输入流</span></div><div class="line">			BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				String msg = reader.readLine();</div><div class="line">				out.println(msg);</div><div class="line">				out.flush();</div><div class="line">				<span class="keyword">if</span> (msg.equals(<span class="string">"bye"</span>)) &#123;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				System.out.println(in.readLine());</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><strong>Client:</strong></p>
<p>hello<br>Server received hello<br>haha<br>Server received haha<br>bye</p>
<p><strong>Server:</strong><br>hello<br>haha<br>bye</p>
<h2 id="多线程通讯"><a href="#多线程通讯" class="headerlink" title="多线程通讯"></a>多线程通讯</h2><p>我们发现，服务器只能处理一个客户端的请求，服务器处理了第一个客户端的请求之后，后续的Client就不能再连接，这个时候我们需要做一些改动，当服务器收到客户端的连接请求后，客户端的请求放在一个新的线程中去处理，而主线程仍然继续等待其他客户端的连接，这样就不会阻塞服务器处理其他客户端的请求了，只需要修改服务器的代码，客户端代码和原来的一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.gduf.bio.socket.demo2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 处理多个client的server</div><div class="line"> * <span class="doctag">@author</span> ZGJ</div><div class="line"> * <span class="doctag">@date</span> 2017年5月4日</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulitClientServer</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span>(ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>)) &#123;</div><div class="line">			<span class="comment">//循环接受客户端请求</span></div><div class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">				Socket socket = server.accept();</div><div class="line">				handle(socket);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 处理客户请求</div><div class="line">	 * <span class="doctag">@param</span> socket</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Socket socket)</span> </span>&#123;</div><div class="line">		<span class="comment">//开启一个线程,lambda表达式</span></div><div class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">			<span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">					PrintWriter writer = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>)) &#123;</div><div class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">					String message =  in.readLine();</div><div class="line">					System.out.println(message);</div><div class="line">					writer.println(<span class="string">"Server received: "</span> + message);</div><div class="line">					<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(message)) &#123;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，当服务器接受到一个客户单的请求之后，采用handle()方法去处理客户端的请求，这里使用了Java8中lambda表达式来替代匿名内部类的语法，来简化我们的编程，使我们的语法更加简洁。对于每一个客户端的请求都开启一个新的线程去处理，当然，如果还想做到更加优化，可以采用Executor线程池去处理，节省创建和关闭线程的开销。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近在准备面试和笔试的一些东西，回去翻看了Java关于IO的基础，发现很多基础还是没有记牢固，现在回头重新学习，就从socket通讯开始吧，虽然说现在企业很少直接编写socket，都是使用一些封装好的框架，netty,mina等。不过对于这些基础的知识，还是需要掌握牢固的，对于以后学习更深的框架和笔试面试都很有裨益。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://zgj12138.github.io/blog/categories/Java/"/>
    
    
      <category term="io" scheme="https://zgj12138.github.io/blog/tags/io/"/>
    
      <category term="socket" scheme="https://zgj12138.github.io/blog/tags/socket/"/>
    
  </entry>
  
</feed>
